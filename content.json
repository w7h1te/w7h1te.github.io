{"meta":{"title":"w7h1te","subtitle":null,"description":"w7h1te的个人博客","author":"w7h1te","url":""},"pages":[{"title":"client","date":"2020-12-20T15:13:35.000Z","updated":"2022-03-10T23:31:06.130Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"该功能还在开发中…….","keywords":"Android客户端"},{"title":"about","date":"2020-12-12T14:14:36.000Z","updated":"2022-03-10T06:10:06.698Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[w7h1te的专属聊天室] w7h1te 正在与&nbsp; w7h1te&nbsp; （ ） 对话中... 对方正在输入... bot_ui_ini()","keywords":"关于"},{"title":"","date":"2022-03-11T01:14:10.273Z","updated":"2022-03-11T01:14:10.273Z","comments":true,"path":"cloud/index.html","permalink":"/cloud/index.html","excerpt":"","text":"layout: cloudtitle: clouddate: 2022-03-11 09:09:06keywords: 资源description:comments: truephotos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg"},{"title":"comment","date":"2020-12-20T15:13:48.000Z","updated":"2022-03-09T11:26:54.032Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"bangumi","date":"2020-02-10T13:32:48.000Z","updated":"2022-03-12T14:27:39.920Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"lab","date":"2020-01-05T13:47:59.000Z","updated":"2022-03-09T11:26:54.056Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"donate","date":"2020-12-20T15:13:05.000Z","updated":"2022-03-09T11:26:54.142Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"","date":"2022-03-11T01:12:02.545Z","updated":"2022-03-11T01:12:02.545Z","comments":true,"path":"idea/index.html","permalink":"/idea/index.html","excerpt":"","text":"layout: ideatitle: ideadate: 2022-03-11 09:09:06keywords: 随想description:comments: truephotos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg"},{"title":"","date":"2022-03-11T01:11:14.291Z","updated":"2022-03-11T01:11:14.291Z","comments":true,"path":"live/index.html","permalink":"/live/index.html","excerpt":"","text":"layout: livetitle: livedate: 2022-03-11 09:09:06keywords: 生活description:comments: truephotos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg"},{"title":"links","date":"2020-12-19T15:11:06.000Z","updated":"2022-03-09T11:26:54.062Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2020-12-20T15:14:28.000Z","updated":"2022-03-09T11:26:54.048Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"","date":"2022-03-11T01:14:10.273Z","updated":"2022-03-11T01:14:10.273Z","comments":true,"path":"reprint/index.html","permalink":"/reprint/index.html","excerpt":"","text":"layout: reprinttitle: reprintdate: 2022-03-11 09:09:06keywords: 转载description:comments: truephotos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg"},{"title":"rss","date":"2020-12-20T15:09:03.000Z","updated":"2022-03-09T11:26:54.126Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-12-12T14:14:16.000Z","updated":"2022-03-10T08:11:18.034Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2022-03-10T10:54:29.517Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://tvax3.sinaimg.cn/large/008kBpBlgy1gwn5ssbgp2j307409wmxs.jpg', title: '进击的巨人 最终季 Part.2', status: '追更中', progress: 70, jp: '進撃の巨人 The Final Season Part.2', time: '首播时间：2022-01-09', desc: ' 在艾伦他们居住的帕拉迪岛之外，还存在一个其他人类居住的世界。当中一个国家「玛雷」与其他各国爆发战争。陷入苦战之际，他们决定要攻进帕拉迪岛，把「始祖的巨人」抢过来。在这里又看到另一群孩子们拼命求生存的身影……。' }, { img : 'https://tvax3.sinaimg.cn/large/008kBpBlgy1gwengmvxr3j307409wdgi.jpg', title: '进击的巨人 最终季 Part.2', status: '追更中', progress: 70, jp: '進撃の巨人 The Final Season Part.2', time: '首播时间：2022-01-09', desc: ' 在艾伦他们居住的帕拉迪岛之外，还存在一个其他人类居住的世界。当中一个国家「玛雷」与其他各国爆发战争。陷入苦战之际，他们决定要攻进帕拉迪岛，把「始祖的巨人」抢过来。在这里又看到另一群孩子们拼命求生存的身影……。' }, { img : 'https://tvax3.sinaimg.cn/large/008kBpBlgy1gwn5ssbgp2j307409wmxs.jpg', title: '进击的巨人 最终季 Part.2', status: '追更中', progress: 70, jp: '進撃の巨人 The Final Season Part.2', time: '首播时间：2022-01-09', desc: ' 在艾伦他们居住的帕拉迪岛之外，还存在一个其他人类居住的世界。当中一个国家「玛雷」与其他各国爆发战争。陷入苦战之际，他们决定要攻进帕拉迪岛，把「始祖的巨人」抢过来。在这里又看到另一群孩子们拼命求生存的身影……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"theme-sakura","date":"2022-03-09T14:53:25.000Z","updated":"2022-03-09T11:09:34.805Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"}],"posts":[{"title":"【转载及推荐】JWT Token的基本使用和基本流程","slug":"【转载】JWT Token的基本使用和基本流程","date":"2022-03-18T08:31:24.000Z","updated":"2022-03-19T16:41:45.809Z","comments":false,"path":"2022/03/18/【转载】JWT Token的基本使用和基本流程/","link":"","permalink":"/2022/03/18/【转载】JWT Token的基本使用和基本流程/","excerpt":"","text":"原文链接 JWT简介JWT(json web token)是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准。 JWT的声明一般被用来在==身份提供者==和==服务提供者==间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。 基于session的登录认证在传统的用户登录认证中，因为http是无状态的，所以都是采用session方式。用户登录成功，服务端会保证一个session，当然会给客户端一个sessionId，客户端会把sessionId保存在cookie中，每次请求都会携带这个sessionId。cookie+session这种模式通常是保存在内存中，而且服务从单服务到多服务会面临的session共享问题，随着用户量的增多，开销就会越大。而JWT不是这样的，只需要服务端生成token，客户端保存这个token，每次请求携带这个token，服务端认证解析就可。 JWT生成Token后的样子eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJvcmciOiLku4rml6XlpLTmnaEiLCJuYW1lIjoiRnJlZeeggeWGnCIsImV4cCI6MTUxNDM1NjEwMywiaWF0IjoxNTE0MzU2MDQzLCJhZ2UiOiIyOCJ9.49UF72vSkj-sA4aHHiYN5eoZ9Nb4w5Vb45PsLF7x_NY JWT的构成第一部分我们称它为头部（header),第二部分我们称其为载荷（payload)，第三部分是签证（signature)。 headerjwt的头部承载==两部分==信息： 声明==类型==，这里是jwt 声明==加密的算法== 通常直接使用 HMAC SHA256 完整的头部就像下面这样的JSON： {undefined “typ”: “JWT”, “alg”: “HS256” } 然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分： eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 playload载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分 标准中注册的声明 公共的声明 私有的声明 标准中注册的声明 (建议但不强制使用) ： iss: jwt签发者 sub: jwt所面向的用户 aud: 接收jwt的一方 exp: jwt的过期时间，这个过期时间必须要大于签发时间 nbf: 定义在什么时间之前，该jwt都是不可用的. iat: jwt的签发时间 jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。 公共的声明 ： 公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密. 私有的声明 ： 私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。 定义一个payload： {undefined “name”:”Free码农”, “age”:”28”, “org”:”今日头条” } 然后将其进行base64加密，得到Jwt的第二部分： eyJvcmciOiLku4rml6XlpLTmnaEiLCJuYW1lIjoiRnJlZeeggeWGnCIsImV4cCI6MTUxNDM1NjEwMywiaWF0IjoxNTE0MzU2MDQzLCJhZ2UiOiIyOCJ9 signaturejwt的第三部分是一个签证信息，这个签证信息由三部分组成： header (base64后的) payload (base64后的) secret 这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分： 49UF72vSkj-sA4aHHiYN5eoZ9Nb4w5Vb45PsLF7x_NY 密钥secret是保存在服务端的，服务端会根据这个密钥进行生成token和验证，所以需要保护好。 java方式实现Maven依赖： &lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; 加密与校验代码： 加密方法与校验方法测试代码： 代码输出结果 可以很清楚的看到，第一次用生成的Token去校验，校验通过，并且输出了Token中包涵的信息。第二次用过期的Token调用校验方法，直接抛出异常，提示Token信息过期。 JWT总结1、因为json的通用性，所以JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用。 2、payload部分，JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。 3、便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。它不需要在服务端保存会话信息, 所以它易于应用的扩展 扩展","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"JAVA","slug":"JAVA","permalink":"/tags/JAVA/"},{"name":"后端","slug":"后端","permalink":"/tags/后端/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]},{"title":"解决端口号占用","slug":"解决端口号占用","date":"2022-03-12T03:27:24.000Z","updated":"2022-03-19T16:46:51.094Z","comments":false,"path":"2022/03/12/解决端口号占用/","link":"","permalink":"/2022/03/12/解决端口号占用/","excerpt":"","text":"问题出现于：端口号冲突，或者上一个使用端口号的进程没有关闭 随便找一个终端窗口：先根据已知端口号查询占用该端口号的进程id netstat -aon|findstr &quot;8888&quot;taskkill /f /t /im 12808","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Markdown编辑小技巧——图片篇（二）","slug":"Markdown编辑小技巧——图片篇（二）","date":"2022-03-05T02:41:24.000Z","updated":"2022-03-14T03:48:02.413Z","comments":false,"path":"2022/03/05/Markdown编辑小技巧——图片篇（二）/","link":"","permalink":"/2022/03/05/Markdown编辑小技巧——图片篇（二）/","excerpt":"","text":"插入图片编辑有时候需要对图像的位置做出调整。这里面大多是针对CSDN的，在这里的样例可能并不是很理想…. 1. 简单调整CSDN调整图片位置其实就是只需要在图片的URL后添加下面代码。代码： #pic_center #pic_right 默认就是左对齐 ![](https://img-blog.csdnimg.cn/img_convert/823c2e3f01988b470bb7abd442280f54.png) ![](https://img-blog.csdnimg.cn/img_convert/1d8e4a5c7f345360c53d205a8b2b1cc5.png#pic_center) ![](https://img-blog.csdnimg.cn/img_convert/e81621de01c32613480e92b9555e0a49.png#pic_right) 2. 使用HTML的标签&lt;img src=&quot;https://...&quot; align=right /&gt; --会与图片并列 &lt;div align=center&gt;&lt;img src=&quot;https://...&quot; &gt;&lt;img/&gt;&lt;/div&gt; --外层加个div块级标签可以解决 &lt;img src=&quot;https://...&quot; width=&quot;200&quot; height=&quot;200&quot; align=right /&gt; ---调节大小 依次： &lt;img src= &quot;https://img-blog.csdnimg.cn/img_convert/823c2e3f01988b470bb7abd442280f54.png&quot; align=right /&gt;这是一只在右边的猫！ 可以看到默认左对齐！ 所以文字在左边！ 这是一只在右边的猫！可以看到默认左对齐！所以文字在左边！ &lt;div align=center&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/823c2e3f01988b470bb7abd442280f54.png&quot; &gt;&lt;img/&gt;&lt;/div&gt;这是一只阳光的猫！ 它跑去中间了！ 文字还在原地！ 这是一只阳光的猫！它跑去中间了！文字还在原地！rust &lt;div align=center&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/823c2e3f01988b470bb7abd442280f54.png&quot; width=&quot;150&quot; height=&quot;150&quot; /&gt;&lt;img/&gt;&lt;/div&gt; &lt;div align=center&gt; 这是一只什么猫啊！ 大到模糊！文字也来中了！ &lt;/div&gt;这是一只什么猫啊！阳光到模糊！文字也来中间了！ 3. 对于从文件里导入方式以及CSDN支持的直接更改位置和大小@import &quot;01.png&quot; {width=&quot;300px&quot; height=&quot;200px&quot; title=&quot;图片的标题&quot; alt=&quot;我的 alt&quot; } ![](https://img-blog.csdnimg.cn/img_convert/fd5d71889f6f4f1a46f49df3e764421e.png#pic_center) 这样的方式在CSDN里面可以正常解析，在这里是不会正常解析的，所以还是使用html的方式更加好一些 4. 图片堆积&lt;img src=&quot;https://gitee.com/yw-7/drawing-bed/raw/master/img/cat.jpeg&quot; width=&quot;150&quot; height=&quot;150&quot; align=right /&gt;&lt;img src=&quot;https://gitee.com/yw-7/drawing-bed/raw/master/img/cat.jpeg&quot; width=&quot;150&quot; height=&quot;150&quot; align=right /&gt; &lt;img src=&quot;https://gitee.com/yw-7/drawing-bed/raw/master/img/cat.jpeg&quot; width=&quot;150&quot; height=&quot;150&quot; align=right /&gt; 可以看到如果直接使用img标签，会出现图片依次并列到右边的问题，如果标签之间加入回车 图片的位置就会变动，根据场景需要可能会不好管理，这时候需要使用div这种块级标签来解决 &lt;div align=center style=&quot;position: absolute;width:100px;height:50px;background:#FE9600;&quot;&gt;&lt;img src=&quot;https://gitee.com/yw-7/drawing-bed/raw/master/img/cat.jpeg&quot; width=&quot;50&quot; height=&quot;50&quot; /&gt;&lt;/div&gt; &lt;div align=center &gt;&lt;img src=&quot;https://gitee.com/yw-7/drawing-bed/raw/master/img/cat.jpeg&quot; width=&quot;50&quot; height=&quot;50&quot; /&gt;&lt;/div&gt; 可以看到每个div快都会独占一行，即时企图直接设置div的style属性 CSDN里的Markdown都是不会解析的中间如果不加其他块，只加回车是不会变动位置的，然而在我们的hexo配置里面，是可以设置的。 注：在这里显示的预期与CSDN上不尽相同，总结一下是因为这边有直接设置div的css选择器、同时对于类似这种url#pic_center，无法达到预期的解析结果","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"Markdown","slug":"Markdown","permalink":"/tags/Markdown/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"后端问题逐一排坑","slug":"后端问题逐一排坑","date":"2022-02-27T02:31:24.000Z","updated":"2022-03-19T16:50:39.495Z","comments":false,"path":"2022/02/27/后端问题逐一排坑/","link":"","permalink":"/2022/02/27/后端问题逐一排坑/","excerpt":"","text":"经过一番查询：解决方案就是删除掉这个.idea文件，重新加载项目发现没有项目目录解决方案如下：成功运行，第一次git提交阶段","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"JAVA","slug":"JAVA","permalink":"/tags/JAVA/"},{"name":"后端","slug":"后端","permalink":"/tags/后端/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"git提交与回退","slug":"git提交与回退","date":"2022-02-15T02:21:24.000Z","updated":"2022-03-19T16:42:36.470Z","comments":false,"path":"2022/02/15/git提交与回退/","link":"","permalink":"/2022/02/15/git提交与回退/","excerpt":"","text":"一、提交1、使用 git status 命令查看做了哪些改变如上图示，master分支修改了pom.xml，新增了四个文件 2、git add &lt;file&gt; 将改动内容提交到暂存区git add . 将所有改动提交到暂存区 3、git commit 将改动内容提交到仓库-m 提交注释 二、还原1、如果改动还未做过任何git操作git checkout -- &lt;file&gt;，还原具体文件git checkout . 还原所有改动文件 2、如果已经提交到暂存区，还未commitgit reset HEAD &lt;file&gt; 3、如果已经commit操作了git reset HEAD^ 回退到上一个版本，但修改内容保留git reset --hard HEAD^ 回退到上一个版本，修改内容不保留 三、GIT_已经提交到远程仓库的错误提交怎么修复和回退已经推到远程的分支上分某次提交发现中间有错误的信息，需要回退进行更改：步骤： 1. 重置git reset HEAD^ 2. 修改并重新commit加上新的修改并提交：git commit -m &quot;New commit message&quot; 3. 强制上传git push --force","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"解决方案","slug":"解决方案","permalink":"/tags/解决方案/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"CSDN将博客都打包成md文件~~（有点小波折）","slug":"CSDN将博客都打包成md文件~~（有点小波折）","date":"2022-02-11T00:41:24.000Z","updated":"2022-03-14T05:14:56.701Z","comments":false,"path":"2022/02/11/CSDN将博客都打包成md文件~~（有点小波折）/","link":"","permalink":"/2022/02/11/CSDN将博客都打包成md文件~~（有点小波折）/","excerpt":"","text":"最近正在进行把博客迁移到我的HEXO-github上，偶然看到了这类文章，亲测好用的一~~~~ 转载自一位大佬的文章：https://segmentfault.com/a/1190000022182081###有用到javascrip 有需求，便会有方案。 简单三步，就可以完成琐碎的活儿啦： 起初我一下释怀了，但是却这里面有个弊端，有点小失望，具体我会在后面讲述………………….. 希望你可以看完本篇文章，并且我会推荐第二种方法…………. 一、打开https://blog-console-api.csdn.net/，记得要先登入好自己的账号，页面虽然显示404但是没有关系。 二、按下F12 ， 找到控制台（console）复制下面代码上去，回车 var s=document.createElement(&#39;script&#39;);document.body.appendChild(s);s.src=&#39;//cdn.jsdelivr.net/gh/ame-yu/csdn-move@latest/dist/index.js&#39;; 三、这时你的文章就已经打包好了，直接点击下载解压就完成了！ 四、别问为什么还有个四，当我下载好之后，我以为都ok准备要去上传博客的时候却发现了……. 等等，只有两个md文件是有数据的，这和我所期待的不太一样呢，然后我就恍悟了原来在这里面呢，并没有说将CSDN种富文本编辑的文章里数据提取出来。但是也是很方便的实现了将我们使用 markdown编辑方式的文章来进行一个提取打包………. 如果要把用富文本编辑的文章也转提取出来，我们还是需要进行一个转换…于是在我的几经搜索下呢又找到了另一位大佬在某乎的文章…. 从零开发一款自动提取网页html并一键转换为md文件的工具(vue源码版) 核心思路就是：获取服务端返回的 html 串 将 html 串 转换为 md 串 同步显示预览到编辑器中 写的很详细，包含 turndown的使用技巧 vue + nuxt项目开发方式 nodejs爬虫相关应用 在其原文最后附上了实现好的github地址，体验了一下确实很赞。支持url直接转md&amp;html转md以及在线预览。 直接附上github在线链接 希望大家如果看到了这篇文章，也推荐去看看这位大佬的其他分享~","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"Markdown","slug":"Markdown","permalink":"/tags/Markdown/"},{"name":"解决方案","slug":"解决方案","permalink":"/tags/解决方案/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Markdown编辑小技巧——文字篇（一）","slug":"Markdown编辑小技巧——文字篇（一）","date":"2022-02-10T12:09:24.000Z","updated":"2022-03-14T03:48:02.365Z","comments":false,"path":"2022/02/10/Markdown编辑小技巧——文字篇（一）/","link":"","permalink":"/2022/02/10/Markdown编辑小技巧——文字篇（一）/","excerpt":"","text":"1.编辑需求：撰写文章，离不开大大小小的标题、序号以及把某处段内词句强调出来，给读者更有效的视觉共鸣。先介绍常用的文字编辑方案，标题、斜体、删除线 、有序和无序标题等都会介绍。 2.文字编辑：1. 加色在CSDN上面可以，但是在这里使用这个方式的时候是不被解析的，所以还是推荐使用html方式 $\\color{#FF0000}{红}$ 其实Markdown也可以使用对应html的代码： 英文字母 这是&lt;label style=&quot;color:red&quot;&gt;红色&lt;/label&gt;字体 这是&lt;label style=&quot;color:green&quot;&gt;绿色&lt;/label&gt;字体 &lt;font color=Yellow&gt;黄色&lt;/font&gt; &lt;font color=YellowGreen&gt;黄绿色&lt;/font&gt; 这是红色字体 这是绿色字体 黄色 黄绿色 十六进制颜色值 &lt;font color=#ff0000&gt;红色&lt;/font&gt; &lt;font color=#00ff00&gt;绿色&lt;/font&gt; &lt;font color=#0000ff&gt;蓝色&lt;/font&gt; 红色绿色蓝色 2. 改变字体大小size：规定文本的尺寸大小，取值范围为1~7 ，浏览器默认值是 3。注意，size=50也是可以显示的，但与7的字体大小一样 &lt;font size=1&gt;字体大小size=1&lt;/font&gt; &lt;font size=3&gt;字体大小size=3&lt;/font&gt; &lt;font size=5&gt;字体大小size=5&lt;/font&gt; &lt;font size=5&gt;字体大小size=7&lt;/font&gt; &lt;font size=5&gt;字体大小size=50&lt;/font&gt; 字体大小size=1字体大小size=3字体大小size=5字体大小size=7字体大小size=50 3. 改变字体类型 注意，字体类型的设置只能在电脑上才能显示字体效果，在手机上无法显示字体类型 &lt;font face=&quot;黑体&quot;&gt;黑体&lt;/font&gt; &lt;font face=&quot;宋体&quot;&gt;宋体&lt;/font&gt; &lt;font face=&quot;仿宋&quot;&gt;仿宋&lt;/font&gt; &lt;font face=&quot;幼圆&quot;&gt;幼圆&lt;/font&gt; &lt;font face=&quot;楷书&quot;&gt;楷书&lt;/font&gt; &lt;font face=&quot;华文行楷&quot;&gt;华文行楷&lt;/font&gt; &lt;font face=&quot;华文隶书&quot;&gt;华文隶书&lt;/font&gt; &lt;font face=&quot;华文新魏&quot;&gt;华文新魏&lt;/font&gt; &lt;font face=&quot;华文彩云&quot;&gt;华文彩云&lt;/font&gt; &lt;font face=&quot;华文琥珀&quot;&gt;华文琥珀&lt;/font&gt; 黑体宋体仿宋幼圆楷书华文行楷华文隶书华文新魏华文彩云华文琥珀 4. 加粗、斜体、删除线**粗体文字**,__粗体文字__ 第二个缺点是在标志符前后假如添加除了符号外的字符，就会有部分显形，不太推荐 __粗体文字__123 ，你好__粗体文字__，?__粗体文字?__? 粗体文字,粗体文字粗体文字123 ，你好粗体文字，?粗体文字?? *斜体*、~~删除线~~ 斜体、删除线 5. 混合使用&lt;b&gt;&lt;font size=5 color=red face=&quot;华文彩云&quot;&gt;华文彩云&lt;/font&gt;&lt;/b&gt; 华文彩云 $\\color{#FF0000}{111111111111}$ &lt;b&gt;&lt;font size=4 color=red face=&quot;华文彩云&quot;&gt;2222222222222&lt;/font&gt;&lt;/b&gt; 2222222222222 3.文章骨架：对如上对于标题效果 的实现代码 ## 2.文章骨架： 1. 有序列表对如上对于有序列表效果 的实现代码，个人感觉针对于(一)、(1)、一、直接写就好 1. 有序列表 2. 无序列表 - 在这里插入代码片 - 在这里插入代码片 - 在这里插入代码片 对于无序列表效果 的效果 在这里插入代码片 在这里插入代码片 在这里插入代码片 3. 引用一个尖括号实现 &gt; 这里是引用 这里是引用 4. 代码块&lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; 单行情况使用“”一个点 在开头结束位置 代码块多行使用：“ `` ”使用者三个点后面加上对应的代码语言名就可以有不一样的效果并且同样以这三个点来结束 5. 超链接样例：在《 Java虚拟机规范（Java SE 8） 》中描述了JVM运行时内存区域结构如下：代码如下： 在《[Java虚拟机规范（Java SE 8）](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4)》中描述了JVM运行时内存区域结构如下： ![jvm运行时内存结构！](https://img-blog.csdnimg.cn/img_convert/1ca124a61bc51f96c66ea12fdfd0fe5f.png#pic_center) 6. 表格规范写法： |姓名|性别|学号| |-|-|-| |莱月昂|男|486| 姓名 性别 学号 莱月昂 男 486 加点空格在末尾打个竖线，看似没什么影响，但是后续再输入其他标识符就会报错，尤其是末尾不加|收尾 | 姓名 | 性别 |学号 |分数 |-|-|-----------|--------| |莱月昂 |男 |486 | 20 姓名 性别 学号 分数 莱月昂 男 486 20","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"Markdown","slug":"Markdown","permalink":"/tags/Markdown/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"jvm调优——实战","slug":"jvm调优实战","date":"2022-01-19T23:16:01.000Z","updated":"2022-03-12T14:10:44.725Z","comments":false,"path":"2022/01/20/jvm调优实战/","link":"","permalink":"/2022/01/20/jvm调优实战/","excerpt":"","text":"一些概念","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"IDEA","slug":"IDEA","permalink":"/tags/IDEA/"},{"name":"JVM","slug":"JVM","permalink":"/tags/JVM/"},{"name":"JAVA","slug":"JAVA","permalink":"/tags/JAVA/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"从jmm、jvm，到对象头、锁（长篇大论）更新中","slug":"从jmm、jvm，到对象头、锁（长篇大论）更新中","date":"2021-11-22T10:29:49.000Z","updated":"2022-03-12T12:48:43.054Z","comments":false,"path":"2021/11/22/从jmm、jvm，到对象头、锁（长篇大论）更新中/","link":"","permalink":"/2021/11/22/从jmm、jvm，到对象头、锁（长篇大论）更新中/","excerpt":"","text":"JMM(java memory model) java内存模型 Java 内存模型指定 Java 虚拟机（jvm）如何使用计算机的内存 (RAM)。Java 虚拟机是整个计算机的模型，因此该模型自然包含一个内存模型——也就是 Java 内存模型。 为什么要有内存模型在介绍Java内存模型之前，先来看一下到底什么是计算机内存模型，然后再来看Java内存模型在计算机内存模型的基础上做了哪些事情。要说计算机的内存模型，就要说一下一段古老的历史，看一下为什么要有内存模型。 内存模型，英文名Memory Model，他是一个很老的老古董了。他是与计算机硬件有关的一个概念。那么我先给你介绍下他和硬件到底有啥关系。 CPU和缓存一致性我们应该都知道，计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的数据，是存放在主存当中的，也就是计算机的物理内存啦。 刚开始，还相安无事的，但是随着CPU技术的发展，CPU的执行速度越来越快。而由于内存的技术并没有太大的变化，所以从内存中读取和写入数据的过程和CPU的执行速度比起来差距就会越来越大,这就导致CPU每次操作内存都要耗费很多等待时间。 为解决上述内存的读写速度慢与发展CPU技术的矛盾， 所以，人们想出来了一个好的办法，就是在CPU和内存之间增加高速缓存。缓存的概念大家都知道，就是保存一份数据拷贝。他的特点是速度快，内存小，并且昂贵。 当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中 而随着CPU能力的不断提升，一层缓存就慢慢的无法满足要求了，就逐渐的衍生出多级缓存。 按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可以分为一级缓存（L1），二级缓存（L2），部分高端CPU还具有三级缓存（L3），每一级缓存中所储存的全部数据都是下一级缓存的一部分。 这三种缓存的技术难度和制造成本是相对递减的，所以其容量也是相对递增的。 当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找 随着计算机能力不断提升，开始支持多线程。那么问题就来了。我们分别来分析下单线程、多线程在单核CPU、多核CPU中的影响。 单线程cpu核心的缓存只被一个线程访问。缓存独占，不会出现访问冲突等问题。 单核CPU，多线程进程中的多个线程会同时访问进程中的共享数据，CPU将某块内存加载到缓存后，不同线程在访问相同的物理地址的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。但由于任何时刻只能有一个线程在执行，因此不会出现缓存访问冲突。 多核CPU，多线程每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。 在CPU和主存之间增加缓存，在多线程场景下就可能存在缓存一致性问题，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。 处理器重排和编译器优化上面提到在在CPU和主存之间增加缓存，在多线程场景下会存在缓存一致性问题。除了这种情况，还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是处理器重排。 除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做编译器优化。 至于为什么重排，我们举个例子，假设你要运一货车苹果，现在你要把苹果装箱上车。你有两种极端的选择：装一箱子苹果，搬到货车边上，再推上去摆到车厢里……一箱一箱的依次进行；另一种方式是先全部装好箱，然后全部搬到货车边上，最后全部挪进去摆好位置。 那种效率更高？很明显是后者，因为前者你就需要不停地在装箱，搬运和上车摆放之间切换，这个切换过程不仅浪费时间，还耗费精力。但是后者一直做一个工作也很无聊，还会导致领导来检查时候车上一箱苹果也没装好，会觉得你在磨蹭摸鱼，所以比较合适的做法就是拿出来两三个箱子，把这些装好，一次多搬运几个过去。这样老板看到就会夸你很有工作效率。 再想想，如果给你多安排有两个人，一个负责装箱，一个负责搬运，一个负责装车，就更快了。 那么编译期重排序有什么好处？CPU计算的时候要访问值，如果常常利用到寄存器中已有的值就不用去内存读取了，比如说： int a = 1; int b = 1; int a = a+1; int b = b+1; 就没有如下的效果好： int a = 1; int a = a+1; int b = 1; int b = b+1; 因为后者的 a或b可能在寄存器中了。 处理器为什么要重排序？因为一个汇编指令也会涉及到很多步骤，每个步骤可能会用到不同的寄存器，CPU使用了流水线技术，也就是说，CPU有多个功能单元（如获取、解码、运算和结果），一条指令也分为多个单元，那么第一条指令执行还没完毕，就可以执行第二条指令，前提是这两条指令功能单元相同或类似，所以一般可以通过指令重排使得具有相似功能单元的指令接连执行来减少流水线中断的情况。 关于重排序分为以下三种： 编译器优化的重排序，编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 指令级并行的重排序。现代处理器采用了指令级并行技术，将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 内存系统的重排序。由于处理器使用了缓存（cpu cache）和读/写缓冲区（store buffers），使得加载和存储操作看上去可能是乱序的。 为了保证内存可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。 JMM 属于语言级的内存模型.它确保在不同的编译器和处理器平台上, 通过禁止特定类型的编译器和处理器重排序, 对外提供一致的内存可见性保证. 在多线程编程中，就涉及到线程之间的通信。为了更好的实现程序的高并发、高性能、高可用，就不得不知道JMM。至于高可用可参考https://www.linuxprobe.com/high-availability.html 并发编程的问题原子性是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 有序性即程序执行的顺序按照代码的先后顺序执行。 有没有发现，缓存一致性问题其实就是可见性问题编译器优化的重排序在不改变单线程程序语义的情况下重新安排语句的执行顺序，所以破坏了顺序性。而处理器的指令级重排序则会破坏原子性。 什么是内存模型所以，为了保证并发编程中可以满足原子性、可见性及有序性。有一个重要的概念，那就是——内存模型。 为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范 通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。 内存模型解决并发问题主要采用两种方式：限制处理器优化和使用内存屏障。 什么是Java内存模型前面介绍过了计算机内存模型，这是解决多线程场景下并发问题的一个重要规范。那么具体的实现是如何的呢，不同的编程语言，在实现上可能有所不同。 我们知道，Java程序是需要运行在Java虚拟机上面的，Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范 简要言之，jmm是jvm的一种规范，定义了jvm的内存模型。它屏蔽了各种硬件和操作系统的访问差异，不像c那样直接访问硬件内存，相对安全很多，它的主要目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。可以保证并发编程场景中的原子性、可见性和有序性。 提到Java内存模型，一般指的是JDK 5 开始使用的新的内存模型，主要由JSR-133: JavaTM Memory Model and Thread Specification描述。 Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。 而JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。 推荐看一下《JAVA并发编程的艺术》 Java内存模型的实现了解Java多线程的朋友都知道，在Java中提供了一系列和并发处理相关的关键字，比如volatile、synchronized、final、concurren包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。 在开发多线程的代码的时候，我们可以直接使用synchronized等关键字来控制并发，从来就不需要关心底层的编译器优化、缓存一致性等问题。所以，Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。 本文并不准备把所有的关键字逐一介绍其用法，因为关于各个关键字的用法，网上有很多资料。读者可以自行学习。本文还有一个重点要介绍的就是，我们前面提到，并发编程要解决原子性、有序性和一致性的问题，我们就再来看下，在Java中，分别使用什么方式来保证。 原子性在Java中，为了保证原子性，提供了两个高级的字节码指令monitorenter和monitorexit。在synchronized的实现原理文章中，介绍过，这两个字节码，在Java中对应的关键字就是synchronized。 因此，在Java中可以使用synchronized来保证方法和代码块内的操作是原子性的。 可见性Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。 Java中的volatile关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性。 除了volatile，Java中的synchronized和final两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。 有序性在Java中，可以使用synchronized和volatile来保证多线程之间操作的有序性。实现方式有所区别： volatile关键字会禁止指令重排。synchronized关键字保证同一时刻只允许一条线程操作。 好了，这里简单的介绍完了Java并发编程中解决原子性、可见性以及有序性可以使用的关键字。读者可能发现了，好像synchronized关键字是万能的，他可以同时满足以上三种特性，这其实也是很多人滥用synchronized的原因。 但是synchronized是比较影响性能的，虽然编译器提供了很多锁优化技术，但是也不建议过度使用。 jvm和jmm之间的关系JVM是对于JMM约定的具体实现方法，将内存分为五个部分，方法区，堆，JVM栈，本地方法栈，程序计数器。前两者属于线程共有，后三者属于线程私有。方法区存储类、常量、JIT即时编译的方法代码，类加载信息的引用等等。堆存储对象。JVM栈主要由方法栈帧组成，栈帧包含方法内的局部变量，操作数栈、动态链接和出口地址。本地方法是JVM本身运行的方法和调用其他语言的区域。程序计数器记录线程执行的地址，方便线程切换。 jmm中的主内存、工作内存与jvm中的Java堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机（甚至是硬件系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问读写的是工作内存。 JVM内存模型程序计数器(PC) 程序计数器是一块很小的内存空间，用于记录下一条要运行的指令。每个线程都需要一个程序计数器，各个线程之中的计数器相互独立，是线程中私有的内存空间 为什么需要程序计数器 我们知道对于一个处理器(如果是多核cpu那就是一核)，在一个确定的时刻都只会执行一条线程中的指令，一条线程中有多个指令，为了线程切换可以恢复到正确执行位置，每个线程都需有独立的一个程序计数器，不同线程之间的程序计数器互不影响，独立存储。 注意：如果线程执行的是个java方法，那么计数器记录虚拟机字节码指令的地址。如果为native【底层方法】，那么计数器为空。这块内存区域是虚拟机规范中唯一没有OutOfMemoryError的区域。 java虚拟机栈 java虚拟机栈也是线程私有的内存空间，它和java线程同一时间创建，由java语言实现的，保存了局部变量、部分结果，并参与方法的调用和返回 本地方法栈 本地方法栈和java虚拟机栈的功能相似，java虚拟机栈用于管理Java函数的调用，而本地方法栈用于管理本地方法的调用，但不是由Java实现的，而是由C实现的 java堆 为所有创建的对象和数组分配内存空间,被JVM中所有的线程共享 方法区 也被称为永久区，与堆空间相似，被JVM中所有的线程共享。方法区主要保存的信息是类的元数据，方法区中最为重要的是类的类型信息、常量池、域信息、方法信息，其中运行时常量池就在方法区，对永久区的GC回收，一是GC对永久区常量池的回收;二是永久区对元数据的回收 在JVM内部使用的java内存模型(JMM)将线程堆栈和堆之间的内存分开 根据JMM模型，在JVM把内存分成了两部分：线程栈区和堆区。 JVM中运行的每个线程都拥有自己的线程栈（也称调用栈），线程栈包含了当前线程执行的方法调用相关信息。随着代码的不断执行，调用栈会不断变化。 线程堆栈thread stack: 1.运行在java虚拟机上的每个线程都有自己的线程堆栈thread stack 2.线程堆栈还包含正在执行的每个方法的所有局部变量,一个线程只能访问它自己的线程堆栈。由线程创建的局部变量对于除创建它的线程之外的所有其他线程都是不可见的。 3.即使两个线程正在执行完全相同的代码，两个线程仍然会在每个线程堆栈中创建该代码的局部变量,一个线程可能会将一个有限变量的副本传递给另一个线程，但它不能共享原始局部变量本身 堆: 1.堆包含在Java应用程序中创建的所有对象，而不管是不是由线程创建的该对象。 2.堆中的对象可以被具有对象引用的所有线程访问。当一个线程访问一个对象时，它也可以访问该对象的成员变量。 3.如果两个线程同时调用同一个对象上的一个方法，它们都可以访问该对象的成员变量，但每个线程都有自己的局部变量副本 4.堆中的数据是共享的,线程不安全的 详细说明： 所有原始类型(boolean,byte,short,char,int,long,float,double)的局部变量都直接保存在线程栈当中，对于它们的值各个线程之间都是独立的。对于原始类型的局部变量，一个线程可以传递一个变量副本给另一个线程，但原始变量是不共享的。 堆区包含了Java应用创建的所有对象信息(包括原始类型的封装类)，不管对象是哪个线程创建的，不管对象是属于一个成员变量还是方法中的局部变量，它都会被存储在堆区。 一个局部变量如果是原始类型，那么它会被完全存储到栈区。 一个局部变量也有可能是一个对象的引用，这种情况下，这个本地引用会被存储到栈中，但是对象本身仍然存储在堆区。 对于一个对象的成员方法，这些方法中包含局部变量，仍需要存储在栈区，即使它们所属的对象在堆区。 对于一个对象的成员变量，不管它是原始类型还是包装类型，都会被存储到堆区。 Static类型的变量以及类本身相关信息都会随着类本身存储在堆区。 基于JMM的JVM模型，既然堆中的数据是共享的，那么在多线程环境中，就可能存在数据安全性问题。主要涉及到：可见性问题，竞争性问题等在此之前，回顾几个点 A、计算机常识： cpu执行的操作是原子性的，是不可拆分的。 B、造成数据安全性问题的必要条件： 多线程环境 多个线程操作共享数据 操作共享数据的语句不是原子性的（多条） 共享对象的可见性如果两个或多个线程共享一个对象，但没有正确使用volatile声明或Synchronized同步机制,一个线程更新了共享变量值后，对于其他线程来讲是不可见的。如线程A,线程B同时要进行modify, public class Account { private float balance; public void modify (float difference) { float value=this.balance; this.balance=value+difference; } } 首先，线程A和线程B在各自的thread stack中维护了一分局部变量的副本，线程A修改修改了线程A中Thread stack中的局部变量，但是还没有还没将修改的数据刷新到Main Memory中，而线程B获取的值依然是old value,就会出现问题 解决方案 使用volatile关键字 使用synchronized同步机制 tips：volatile与synchronized的区别： volatile本质是在告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取；synchronized则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住 volatile仅修饰变量；synchronized则可以修饰变量、方法、代码块 volatile仅保证可见性；synchronized则可以保证可见性和原子性 volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞 volatile修饰的变量会禁止指令重排序，因而程序不会被编译器优化；synchronized修饰的变量没有禁止指令重排序，因而程序可以被编译器优化 关于对象头，先从Java的对象模型谈起Java是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。 HotSpot虚拟机中，设计了一个OOP-Klass Model。OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。 每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个instanceKlass，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了对象头以及实例数据。 HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。java对象头很重要，synchronize、GC、HashCode、biasedLock、ObjectMonitor都是在对象头上做文章。 在JVM存储时，为了实现一些额外的功能，需要在对象中添加一些标记字段用于增强对象功能，这些标记字段组成了对象头。Mark Word：用来标记运行时信息。Class Pointer：用来指向生成该对象所在的类。如果是数组对象还得再加一项Array Length：告诉我们数组的长度。 这里以32位JVM为例： 普通对象 数组对象 Mark Word（标记字段）通过阅读open jdk官方文档中对对象头的解释可以知道，一个Java对象头中包含了2个word。第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等。第二个word是klass word，主要是指向对象的元数据 。 关于Word（字）：指的是计算机内存中占据 一个单独的内存单元编号的一组二进制串。一般32位计算机上一个字为4个字节长度。1 Byte = 8Bits。 这部分数据的长度在32位和64位的虚拟机（暂不考虑开启压缩指针的场景）中分别为32个和64个Bits，官方称它为“Mark Word”。mark word的位长度为JVM的一个Word大小，也就是说32位JVM的Mark word为32Bits，64位JVM为64Bits。（64位虚拟机情况下，markWord、class pointer、array length一般都是8字节） 考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟机 中对象未被锁定的状态下，Mark Word的32个Bits空间中的25Bits用于存储对象哈希码（HashCode），4Bits用于存储对象分代年龄，2Bits用于存储锁标志 位，1Bit固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下表所示。 其中各部分的含义如下：lock:2位的锁状态标记位，由于希望用尽可能少的二进制位表示尽可能多的信息，所以设置了lock标记。该标记的值不同，整个mark word表示的含义不同。 biased_lock：对象是否启用偏向锁标记，只占1个二进制位。为1时表示对象启用偏向锁，为0时表示对象没有偏向锁。age：4位的Java对象年龄。在GC中，如果对象在Survivor区复制一次，年龄增加1。当对象达到设定的阈值时，将会晋升到老年代。默认情况下，并行GC的年龄阈值为15，并发GC的年龄阈值为6。由于age只有4位，所以最大值为15，这就是-XX:MaxTenuringThreshold选项最大值为15的原因。identity_hashcode：25位的对象标识Hash码，采用延迟加载技术。调用方法System.identityHashCode()计算，并会将结果写到该对象头中。当对象被锁定时，该值会移动到管程Monitor中。thread：持有偏向锁的线程ID。epoch：偏向时间戳。ptr_to_lock_record：指向栈中锁记录的指针。ptr_to_heavyweight_monitor：指向管程Monitor的指针。 64位下的标记字与32位的相似： 锁有不同的分类。分别是:无锁态、偏向锁、轻量级锁 (自旋锁，自适应自旋）、重量级锁。锁的相关信息必然是要被记录的而记录的载体正是对象的对象头中的markword。此外由于存储空间的有限，为了节省空间，提高空间利用率64位虚拟机下，我们将markword这8个字节根据不同的锁状态划分成了不同的结构。其中锁状态与markword的关系入下图所示。 关于锁的介绍，具体我会在后面，详细的说明。 class pointer对象头的另外一部分是类型指针，即是对象指向它的类的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说查找对象的元数据信息并不一定要经过对象本身。另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中无法确定数组的大小。 这一部分用于存储对象的类型指针，该指针指向它的类元数据，JVM通过这个指针确定对象是哪个类的实例。该指针的位长度为JVM的一个字大小，即32位的JVM为32位，64位的JVM为64位。如果应用的对象过多，使用64位的指针将浪费大量内存，统计而言，64位的JVM将会比32位的JVM多耗费50%的内存。为了节约内存可以使用选项+UseCompressedOops开启指针压缩，其中，oop即ordinary object pointer普通对象指针。开启该选项后，下列指针将压缩至32位： 每个Class的属性指针（即静态变量） 每个对象的属性指针（即对象变量） 普通对象数组的每个元素指针 当然，也不是所有的指针都会压缩，一些特殊类型的指针JVM不会优化，比如指向PermGen的Class对象指针(JDK8中指向元空间的Class对象指针)、本地变量、堆栈元素、入参、返回值和NULL指针等。 array length如果对象是一个数组，那么对象头还需要有额外的空间用于存储数组的长度，这部分数据的长度也随着JVM架构的不同而不同：32位的JVM上，长度为32位；64位JVM则为64位。64位JVM如果开启+UseCompressedOops选项，该区域长度也将由64位压缩至32位。 附上参考资料： CompressedOops - CompressedOops - OpenJDK Wiki 实例数据（Instance Data）接下来实例数据部分是对象真正存储的有效信息，也既是我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的都需要记录下来。 这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义顺序的影响。HotSpot虚拟机 默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果 CompactFields参数值为true（默认为true），那子类之中较窄的变量也可能会插入到父类变量的空隙之中。 对齐填充（Padding） 第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。对象头正好是8字节的倍数（1倍或者2倍），因此当对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。 对象的访问定位java程序需要通过引用(ref)数据来操作堆上面的对象，那么如何通过引用定位、访问到对象的具体位置。 对象的访问方式由虚拟机决定，java虚拟机提供两种主流的方式 1.句柄访问对象 2.直接指针访问对象。(Sun HotSpot使用这种方式) 参考Java对象访问定位 句柄访问 简单来说就是java堆划出一块内存作为句柄池,引用中存储对象的句柄地址,句柄中包含对象实例数据、类型数据的地址信息。 优点:引用中存储的是稳定的句柄地址,在对象被移动【垃圾收集时移动对象是常态】只需改变句柄中实例数据的指针，不需要改动引用【ref】本身。 直接指针 与句柄访问不同的是，ref中直接存储的就是对象的实例数据,但是类型数据跟句柄访问方式一样。 优点:优势很明显，就是速度快，相比于句柄访问少了一次指针定位的开销时间。【可能是出于Java中对象的访问时十分频繁的,平时我们常用的JVM HotSpot采用此种方式】 内存溢出两种内存溢出异常[注意内存溢出是error级别的] 1.StackOverFlowError:当请求的栈深度大于虚拟机所允许的最大深度 2.OutOfMemoryError:虚拟机在扩展栈时无法申请到足够的内存空间[一般都能设置扩大] java -verbose:class -version 可以查看刚开始加载的类，可以发现这两个类并不是异常出现的时候才去加载，而是jvm启动的时候就已经加载。这么做的原因是在vm启动过程中我们把类加载起来，并创建几个没有堆栈的对象缓存起来，只需要设置下不同的提示信息即可，当需要抛出特定类型的OutOfMemoryError异常的时候，就直接拿出缓存里的这几个对象就可以了。 比如说OutOfMemoryError对象，jvm预留出4个对象【固定常量】，这就为什么最多出现4次有堆栈的OutOfMemoryError异常及大部分情况下都将看到没有堆栈的OutOfMemoryError对象的原因。 参考OutOfMemoryError解读 再说说JVM中的锁看完对象头，往下看虚拟机中对锁的一些实现，Java程序中对于多线程的同步操作并不是全部交由操作系统来完成的，JVM也会参与进来，例如遇到线程访问临界区资源但没能获得锁而等待时，JVM不会立刻让操作系统挂起线程，而是做一些例如自旋操作，让线程尽可能拿到锁，这样做的目的是尽可能提高程序运行速度，因为线程拿不到锁后进入阻塞态，等待下一次获取锁后进入就绪态再到运行态，这一系列动作需要耗费较大的性能和时间。 先来看看synchronized机制，synchronized机制有四种用法，一种是对代码块标记，第二种对静态方法进行标记，第三种对非静态方法进行标记，第四种对类进行标记。其中反编译之后可以看到，class文件中的指令通过monitorenter和monitorexit来标识代码片段是互斥的，如果是方法，方法名之前会有ACC_SYNCHRONIZED的标识。 至于底层实现，jvm通过一系列的队列来保证synchronized能够线程安全的试用。每一个对象都有一个monitor来控制是否是竞争性资源。现有的机制通过对对象头的标记来简化锁带来的负载，偏向锁，不存在竞争的线程获取资源，第二次进入不再进行同步操作。轻量锁，先尝试修改mark word的状态为轻量锁，修改成功就执行同步的代码，此时有竞争的线程自旋，自旋之后如果还不能获取到资源，锁变成重量锁。自旋锁，线程空转以免引起操作系统上下文切换。重量锁，通过synchronized机制来操作，只有在其他线程执行了monitorexit之后才能获获取资源。 vilatile 是能够保证可见性和有序性。应用场景有状态标志（开关）、双重检查锁定，在底层的实现主要依靠锁，但是vilatile并不能保证原子性，所以不是线程安全的机制。对单个volatile变量的读/写具有原子性，但是部分操作不具有，比如volatile++这样的操作 偏向锁 首先来看偏向锁，它的做法是，如果一个线程A获取了锁对象，那么这个锁对象就进入了偏向状态，Mark Word中标记为biased_lock:1 | 01，同时经过CAS无锁交换比较（compare and swap）操作后记录线程id，线程执行完释放锁之后，如果想要再次获得该锁对象，则不需要再进行加锁，cas等同步操作。当然，如果有其他线程试图去获取该锁对象时，这个偏向状态就会失效。 轻量级锁轻量级锁在JVM内部实现用的是BasicObjectLock类，类里面有轻量锁对象BasicLock，线程如果获取偏向锁失败，就会转去申请轻量级锁，轻量级锁的就是先让线程进行CAS操作来同步，期间还会将原来对象的Mark Word进行备份，然后复制BasicLock的地址到Mark Word中，如果BasicLock地址复制成功，表示线程处于轻量级锁状态，Mark Word中标记lock为00。如果地址复制失败，先会去判断线程是否之前就已经获得了锁对象，如果是就直接进入同步块，如果没有，则表明有多个线程在获取同一对象，此时轻量级锁就会膨胀成重量级锁。 关于对象头和锁之间的转换，网上大神总结 …… 关于CAS操作 参考资料： JVM内存结构 VS Java内存模型 VS Java对象模型-HollisChuang’s Blog java对象在内存中的结构（HotSpot虚拟机） - duanxz - 博客园 【Java对象解析】不得不了解的对象头_扬帆舟的博客-CSDN博客 Java对象头详解 - 追求极致 - 博客园 深入理解JVM-内存模型（jmm）和GC - 简书 JMM与JVM区别与联系（精炼总结） - it610.com","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"JVM","slug":"JVM","permalink":"/tags/JVM/"},{"name":"JAVA","slug":"JAVA","permalink":"/tags/JAVA/"},{"name":"锁","slug":"锁","permalink":"/tags/锁/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"jvm调优——栈上分配","slug":"jvm的部分操作，jvm调优——栈上分配。","date":"2021-10-12T01:16:01.000Z","updated":"2022-03-14T03:48:02.390Z","comments":false,"path":"2021/10/12/jvm的部分操作，jvm调优——栈上分配。/","link":"","permalink":"/2021/10/12/jvm的部分操作，jvm调优——栈上分配。/","excerpt":"","text":"x.1 简介java虚拟机提供的一项优化技术。 基本思想即：对于那些线程私有的对象（这里指不可能被其他线程访问的对象），可以将他们打散分配在栈上，而不是分配在堆上。 好处：可以在函数调用结束后自行销毁，而不需要垃圾回收器的介入，从而提高系统的性能。 x.2 实现技术基础是进行逃逸分析。逃逸分析的目的是判断对象的作用域是否有可能逃逸出函数体。 private static User u; public static void alloc(){ u = new User(); u.id = 7; u.name = &quot;分配内存&quot;; } 对象User u 是类的成员变量，该字段有可能被任何线程访问，因此属于逃逸对象。 public static void alloc(){ User u = new User(); u.id = 7; u.name = &quot;分配内存&quot;; } 此时，对象User以局部变量的形式存在，且该对象并没有被alloc()函数返回，或者出现任何形式的公开。属于并未发生逃逸，此种情况下，虚拟机就有可能将User分配在栈上，而不在堆上。 再举示例分析： public class OnStackTest { public static class User{ public int id=0; public String name=&quot;&quot;; } public static void alloc(){ User u = new User(); u.id = 7; u.name = &quot;fpnc&quot;; } public static void main(String[] args) throws InterruptedException{ long b=System.currentTimeMillis(); for(int i=0;i&lt;100000000;i++){ alloc(); } long e=System.currentTimeMillis(); System.out.println(e-b); } } 上述代码在主函数中进行了1亿次alloc()调用来创建对象，由于这个User对象实例需要占据约16字节的空间，因此，累计分配空间将近1.5GB。如果堆内存的空间小于这个值，就必然会发生GC。 应用如下参数运行上述代码： \\-server -Xmx10m -Xms10m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-UseTLAB -XX:+EliminateAllocations 这里使用参数-server执行程序，因为在Server模式下，才可以启用逃逸分析。参数-XX:+DoEscapeAnalysis启用逃逸分析，-Xmx10m指定了堆空间最大为10MB。显然,如果对象在堆上分配，必然会引起大量的GC。如果GC真的发生了，参数-XX:+PrintGC将打印GC日志。参数-XX:+ EliminateAllocations开启了标量替换(默认打开)，允许将对象打散分配在栈上，比如对象拥有id和name两个字段,那么这两个字段将会被视为两个独立的局部变量进行分配。参数-XX:-UseTLAB关闭了TLAB。 推荐去看看这篇博主写的TLAB TLAB Thread Local Allocation Buffer 线程本地分配缓存 一个线程专用的内存分配区域，为了加速对象分配 每一个线程，都会产生一个TLAB，该线程独享的工作区域 每一个线程，都会默认使用TLAB区域 TLAB用来避免多线程冲突问题，提高对象分配效率 内存大小 TLAB空间一般不会太大 eden区放不下，优先，分配到TLAB区 TLAB区也放不下，会直接分配在堆上 JVM JVM中，创建对象的时候 TLAB区域，可以提高对象的创建效率 x.3实战环节未修改jvm参数，程序执行后，完整的输出如下: 看起来没什么问题，接着按如下操作修改这次项目的jvm参数，加上 -server -Xmx10m -Xms10m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-UseTLAB -XX:+EliminateAllocations 结果如下： 然鹅我加上我们的jvm参数，发现竟然耗时相同而且进行了两次GC，说好的优化呢？ 这里不得不说所使用的idea2021.2版，默认jvm的部分参数： -Xmx750m -XX:ReservedCodeCacheSize=512m（idea的缓存大小） -Xms128m -XX:+UseG1GC 控制变量法不能忽略呀，再次修改参数为 -Xmx10m -Xms10m -XX:+PrintGC -XX:-UseTLAB 可以明显看到，还是肥肠好用的。 此外，推荐扩展阅读： JVM调优实战总结！","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"IDEA","slug":"IDEA","permalink":"/tags/IDEA/"},{"name":"JVM","slug":"JVM","permalink":"/tags/JVM/"},{"name":"JAVA","slug":"JAVA","permalink":"/tags/JAVA/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"人家问你：什么是JVM内存结构 、 Java内存模型 、 Java对象模型？","slug":"人家问你：什么是JVM内存结构 、 Java内存模型 、 Java对象模型","date":"2021-10-09T08:56:08.000Z","updated":"2022-03-12T11:41:21.277Z","comments":false,"path":"2021/10/09/人家问你：什么是JVM内存结构 、 Java内存模型 、 Java对象模型/","link":"","permalink":"/2021/10/09/人家问你：什么是JVM内存结构 、 Java内存模型 、 Java对象模型/","excerpt":"","text":"你说：啊对对对！？ 文章出自：JVM内存结构 VS Java内存模型 VS Java对象模型-HollisChuang’s Blog JVM内存结构我们都知道，Java代码是要运行在虚拟机上的，而虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途。其中有些区域随着虚拟机进程的启动而存在，而有些区域则依赖用户线程的启动和结束而建立和销毁。 在《 Java虚拟机规范（Java SE 8） 》中描述了JVM运行时内存区域结构如下： 各个区域的功能不是本文重点，就不在这里详细介绍了。这里简单提几个需要特别注意的点： 1、以上是Java虚拟机规范，不同的虚拟机实现会各有不同，但是一般会遵守规范。 2、规范中定义的方法区，只是一种概念上的区域，并说明了其应该具有什么功能。但是并没有规定这个区域到底应该处于何处。所以，对于不同的虚拟机实现来说，是由一定的自由度的。 3、不同版本的方法区所处位置不同，上图中划分的是逻辑区域，并不是绝对意义上的物理区域。因为某些版本的JDK中方法区其实是在堆中实现的。 4、运行时常量池用于存放编译期生成的各种字面量和符号应用。但是，Java语言并不要求常量只有在编译期才能产生。比如在运行期，String.intern也会把新的常量放入池中。 5、除了以上介绍的JVM运行时内存外，还有一块内存区域可供使用，那就是直接内存。Java虚拟机规范并没有定义这块内存区域，所以他并不由JVM管理，是利用本地方法库直接在堆外申请的内存区域。 6、堆和栈的数据划分也不是绝对的，如HotSpot的JIT会针对对象分配做相应的优化。 如上，做个总结，JVM内存结构，由Java虚拟机规范定义。描述的是Java程序执行过程中，由JVM管理的不同数据区域。各个区域有其特定的功能。 Java内存模型Java内存模型看上去和Java内存结构（JVM内存结构）差不多，很多人会误以为两者是一回事儿，这也就导致面试过程中经常答非所为。 在前面的关于JVM的内存结构的图中，我们可以看到，其中Java堆和方法区的区域是多个线程共享的数据区域。也就是说，多个线程可能可以操作保存在堆或者方法区中的同一个数据。这也就是我们常说的“Java的线程间通过共享内存进行通信”。 Java内存模型是根据英文Java Memory Model（JMM）翻译过来的。其实JMM并不像JVM内存结构一样是真实存在的。他只是一个抽象的概念。JSR-133: Java Memory Model and Thread Specification中描述了，JMM是和多线程相关的，他描述了一组规则或规范，这个规范定义了一个线程对共享变量的写入时对另一个线程是可见的。 那么，简单总结下，Java的多线程之间是通过共享内存进行通信的，而由于采用共享内存进行通信，在通信过程中会存在一系列如可见性、原子性、顺序性等问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。 在Java中，JMM是一个非常重要的概念，正是由于有了JMM，Java的并发编程才能避免很多问题。这里就不对Java内存模型做更加详细的介绍了，想了解更多的朋友可以参考《Java并发编程的艺术》。 Java对象模型Java是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。 HotSpot虚拟机中，设计了一个OOP-Klass Model。OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。 每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个instanceKlass，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了对象头以及实例数据。 这就是一个简单的Java对象的OOP-Klass模型，即Java对象模型。 【理解HotSpot虚拟机】对象在jvm!链机制,建议将下的表示：OOP-Klass模型接nxd(CSDi博客_klass 总结我们再来区分下JVM内存结构、 Java内存模型 以及 Java对象模型 三个概念。 JVM内存结构，和Java虚拟机的运行时区域有关。 Java内存模型，和Java的并发编程有关。 Java对象模型，和Java对象在虚拟机中的表现形式有关。 后面我会将本文中所引申的内容整理分享出来。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"JVM","slug":"JVM","permalink":"/tags/JVM/"},{"name":"JAVA","slug":"JAVA","permalink":"/tags/JAVA/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Mysql调优(一)","slug":"Mysql调优（一）","date":"2021-09-20T14:37:26.000Z","updated":"2022-03-14T05:32:53.229Z","comments":false,"path":"2021/09/20/Mysql调优（一）/","link":"","permalink":"/2021/09/20/Mysql调优（一）/","excerpt":"","text":"一、执行计划:Explain查询下面三个重要相关的列:Type/Key/exture 引一下比较不错的解释： Type列: possible_key列 + key列： exture列此字段显示一些额外的信息，但是此字段的部分值具有优化的参考意义。 （1）using where：表示查询使用了where 语句来处理结果 （2）using index：表示使用了覆盖索引。这个值重点强调了只需要使用索引就可以满足查询表的要求，不需要直接访问表数据。 （3）using join buffer：这个值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进性能 （4）using filesort：这是 order by 语句的结果。这可能是一个CPU密集型的过程。using filesort表示出现了文件内排序，表示很不好的现象，必须要优化，特别是大表，可以通过选择合适的索引来改进性能，用索引来为查询结果排序。 （5）using temporary：mysql需要创建一张临时表来保存中间结果。 也就是说，需要先把数据放到临时表中，然后从临时表中获取需要的数据。出现这种临时表，也是必须需要优化的地方，特别是数据量大的情况。两个常见的原因是在来自不同表的列上使用了distinct，或者使用了不同的 order by 和 group by 列。 二、索引2.1.MySQL的索引数据和实际数据都存储在磁盘，而非内存2.2.当启动数据库服务时，才将数据库的索引文件读取(加载)到内存中去。2.3.分块进行数据读取.(索引和数据量都非常大，内存放不下)(页的整数倍) 涉及到部分操作系统知识：【局部性原理时间局部性:之前被访问的数据，很有可能很快被再次访问空间局部性:数据和程序都有聚集成群的倾向，具备某些特征的数据可以放在一起磁盘预读:内存和磁盘在进行交互的时候，有一个最基本的逻辑单位，称为页，也叫datapage，大小一般是4k或者8k，我们在进行数据读取的时候，一般读取的是页的整数倍innodb默认页大小16k】 2.4.考虑数据结构存储(格式:K-V)。2.4.1 哈希表(memory,heap在内存中，innodb自适应哈希): 特点：哈希冲突、散列(均等分在对应的数组下标下)、如果某一位置的链表过长，那么造成空间上的浪费，就需要更好的哈希算法优化(jdk1.8以后，扰动函数：让二进制高位参加运算)。无序，范围查询效率非常低，只能挨个遍历。 【 innodb引擎四大特性概要:1.插入缓冲(insertBuffer/ChangeBuffer)提升插入性能。change-buffering，是insert-buffer的加强，insert-buffer只针对insert有效，change-buffering对insert、delete、update（delete+insert）、purge都有效。 只对于非聚集索引（非唯一)的插入和更新有效。对于每一次的插入，不是写到索引页中。而是先判断插入的非聚集索引页是否在缓冲池中，如果在，则直接插入；若不在，则先放到insert-buffer,再按照一定的频率进行合并操作，在写回disk。这样通常能将多个插入合并到一个操作中。目的还是为了减少随机IO带来性能损耗。 使用插入缓冲的条件：* 非聚集索引* 非唯一索引 2.二次写（double-write）Double-write缓存是位于系统表空间的存储区，用来缓存innodb的数据页，从innodb-buffer-pool中,-Flush之后，并写入到数据文件之前，所以当操作系统或者数据库进程在数据页写磁盘的过程中崩溃。innodb也可以在double-write的缓存中找到数据页的备份儿，用来执行crash恢复。数据页写入到double-write缓存的动作所需要的IO消耗要小于写入到数据文件的消耗。因此写入操作会以一次大的连续块的方式写入。 3.自适应哈希（ahi）条件比较苛刻。一，所索引是否被访问了17次。二、索引中的某个页已经被访问了100次。三、访问模式必须是一样的。 4.预读（read-ahead）InnoDB使用两种预读算法来提高I/O性能：线性预读（linear read-ahead）和随机预读（randomread-ahead） 】 这里只是部分介绍：具体推荐去看这篇博主。 2.4.2 B+树: 推荐跳过去看，为什么MySQL的索引使用B+树，在此处不加赘述。 带着几个问题去看吧：为什么使用B+树？解决了什么问题？B+树与B-树的区别，相对于存储数据，B+树的结构优化了哪些？对查询等操作效率的影响？数据在磁盘的存取过程中，数据缺失问题减少的原因是否与B+树的链表有关？ 2.5.IO层面减少io次数，减少io量2.6.数据迁移关掉索引尽量自增","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"IDEA","slug":"IDEA","permalink":"/tags/IDEA/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"},{"name":"Mysql","slug":"Mysql","permalink":"/tags/Mysql/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2020-12-12T14:16:01.000Z","updated":"2022-03-11T09:36:48.518Z","comments":true,"path":"2020/12/12/Hexo-Theme-Sakura/","link":"","permalink":"/2020/12/12/Hexo-Theme-Sakura/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 958139733 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢本站的sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 在次声明本博客主题其实以该(https://github.com/honjun/hexo-theme-sakura)源码的作者为基础，在此感谢其源码的提供，进行二次开发，改进…后面将为大家提供其为广大萌新使用者提供的教程. 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.bibilink.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"},{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"生活","slug":"生活","permalink":"/tags/生活/"},{"name":"资源","slug":"资源","permalink":"/tags/资源/"},{"name":"随想","slug":"随想","permalink":"/tags/随想/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"图集","slug":"图集","permalink":"/tags/图集/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"idea","slug":"idea","date":"2020-12-12T14:16:01.000Z","updated":"2022-03-14T03:48:02.425Z","comments":false,"path":"2020/12/12/idea/","link":"","permalink":"/2020/12/12/idea/","excerpt":"","text":"后知后觉时间:2016-08-08 14:05:41 阅读:244 短文学:~芸萱残影~ 最美的遇见；最初的爱恋；最深的思念；最久的陪伴；最终化作一缕缕青烟～ 一起时，说着最伤人的话，做着最伤人的事，因为知道不会离开；离开时，依旧说着最伤人的话，做着最伤人的事，只不过主体变成了自己，那时才明白了什么叫刻骨铭心，什么叫痛定思痛…… 最怕突然的不见，最怕突然的思念，最怕无法再相恋……你的离开，带走的除了那颗爱你的心，还有我的灵魂；因为你，我的生活变得索然无味，我的人生变得空洞寂寞，每天的日子如同行尸走肉般不再富有朝气……仿佛一切都变成了思念，变成了情愫，渴望再次的遇见，再次的相恋。开始怀念昔日的美好，昔日的星空，昔日的绿林小路……于是怀揣着思念，去走来时的路，最后收获的仅仅四个字：物是人非。真是欲语泪先流…… 后来，明白了：逝去的终究逝去，未来还是要继续。于是，重振旗鼓，继续向前，只是多了一丝惆怅，一丝怅惘。内心告诉自己：谁的青春不疯狂，谁的青春不迷茫，谁的青春不犯错！青涩的爱情是我青春的过错，青春的遇见是哒哒的马蹄后的过客，我的归人就在灯火阑珊处等待我的蓦然回首！即使过错，不再错过，静待下一次遇见，善待下一次的感情。痛过才能更好的成蝶，恋过才能更好的蜕变！每一次的痛都会让我们更好的成长和成熟，那时的我们会真正的学会：即使泪水在眼里打转，却依旧可以微笑！ 遇见；相恋；理解；信任；包容地守护彼此！ 就像生活中从某些事看到你的影子，不觉然地笑了。才知道那永远回不去的从前，是多么的令人感到惬意。这是每个都有的恋旧情怀，不然又怎会好奇地来看看呢?","categories":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"},{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"生活","slug":"生活","permalink":"/tags/生活/"},{"name":"资源","slug":"资源","permalink":"/tags/资源/"},{"name":"随想","slug":"随想","permalink":"/tags/随想/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"图集","slug":"图集","permalink":"/tags/图集/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}]},{"title":"转载","slug":"zhuanzai","date":"2020-12-12T14:16:01.000Z","updated":"2022-03-11T08:57:35.334Z","comments":false,"path":"2020/12/12/zhuanzai/","link":"","permalink":"/2020/12/12/zhuanzai/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 958139733","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"资源","slug":"资源","permalink":"/tags/资源/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]},{"title":"资源","slug":"ziyuan","date":"2020-12-12T14:16:01.000Z","updated":"2022-03-14T03:48:02.345Z","comments":false,"path":"2020/12/12/ziyuan/","link":"","permalink":"/2020/12/12/ziyuan/","excerpt":"","text":"关于一些技术类 网站工具箱，会后续分享………有关博主java相关的其它技术博客分享，请到主页点击CSDN等相关分享平台……. 支持url直接转md&amp;html转md以及在线预览的网页工具","categories":[{"name":"资源","slug":"资源","permalink":"/categories/资源/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"资源","slug":"资源","permalink":"/tags/资源/"}],"keywords":[{"name":"资源","slug":"资源","permalink":"/categories/资源/"}]},{"title":"Vue结合项目开发 踩坑....","slug":"Vue结合项目开发 踩坑....","date":"2020-09-06T04:41:24.000Z","updated":"2022-03-19T16:43:22.439Z","comments":false,"path":"2020/09/06/Vue结合项目开发 踩坑..../","link":"","permalink":"/2020/09/06/Vue结合项目开发 踩坑..../","excerpt":"","text":"直接上图：原因很简单，但是就是没想到，哎启动目录问题：应该到对应的Vue项目路径下去运行npm run serve 我们可以在终端输入： cd [你的项目名]也可以，用idea可视化操作： 以为这就行了？很快啊，其实又来了一个常见的坑。这个98%真的很恐怖。显示了This relative module was not found:真的不要多想，马上去找你的路径问题….最终定位到这一行代码上改成“.”就好了。这样就成功了！ 背景图片不加载1.先去看引用路径对不对2.去找自己页面配置","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"IDEA","slug":"IDEA","permalink":"/tags/IDEA/"},{"name":"Vue","slug":"Vue","permalink":"/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"/tags/前端/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"hexo的简要使用文档","slug":"hello-world","date":"2020-07-26T02:16:01.000Z","updated":"2022-03-12T14:10:44.717Z","comments":true,"path":"2020/07/26/hello-world/","link":"","permalink":"/2020/07/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]},{"title":"【转载及推荐】Vue，webpack，node之间的关系","slug":"Vue学习疑问：你一口一个渲染、挂载所以到底应该怎么理解？","date":"2020-06-20T16:01:30.000Z","updated":"2022-03-14T05:41:18.306Z","comments":false,"path":"2020/06/21/Vue学习疑问：你一口一个渲染、挂载所以到底应该怎么理解？/","link":"","permalink":"/2020/06/21/Vue学习疑问：你一口一个渲染、挂载所以到底应该怎么理解？/","excerpt":"","text":"前情提要：在刚接触到vue时，总会出现几个名词：渲染、挂载、热更新等等，所以到底应该怎么去理解呢？以及引申到一些设计模式的知识，可以顺便了解。 Vue渲染方式 Vue中的渲染方式个人总结可分为4种: 原有模板语法，挂载渲染 使用render属性，createElement函数直接渲染 使用render属性，配合组件的template属性，createElement函数渲染 使用render属性，配合单文件组件，createElement函数渲染 超详细的Vue渲染原理讲解MVVM、MVP和MVCMVVM，即model、view、view-model，业务层、视图层以及两者的绑定层。Vue的设计参考了MVVM架构，但不完全是一个MVVM框架，因为它没有严格意义上的绑定层。 MVVM要求开发者将业务层和视图层分开：业务层负责管理数据；视图层负责页面渲染；绑定层负责双向绑定，即视图层操作通过绑定层影响业务数据，业务数据的变化通过绑定层影响视图渲染，这三层是完全解耦的：MVVM模式参考自MVP模式，而两者都是借鉴自经典的MVC模式。先来说说MVVM和MVP的差异。开发者需要定义当变量变化时如何更新视图，以及获取到用户输入时如何更新变量，这两者加起来就是它的Presenter层实现。这种方式也可以实现视图和业务逻辑的同步，但显然，MVP的控制层逻辑要比MVVM的声明式绑定写起来复杂得多，所以MVP模式基本上已经被MVVM代替。 vue和react渲染的区别是什么？区别：1、React是通过JSX渲染模板；而Vue是通过一种拓展的HTML语法进行渲染。2、Vue在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树；而React在应用的状态被改变时，全部子组件都会重新渲染。知乎文章：https://zhuanlan.zhihu.com/p/100228073 react和vue该选哪一个? 挂载挂载一词来自操作系统的概念，原意是虚拟文件系统与硬件驱动建立关系，通过操作虚拟文件系统，间接操作真实的文件。打个比方，u盘操作的实质是通过虚拟文件系统建立与真实u盘文件的映射关系，用户操作的文件增删改查都是针对虚拟文件目录，虚拟文件系统会处理真实的文件操作。u盘真实文件系统与虚拟文件系统建立关系的过程，叫做挂载。回到浏览器上，虚拟dom与真实dom建立关系的过程，也可以称作挂载。因为都是“虚拟”与“真实”建立联系，用户操作“虚拟”部分。 vue组件挂载与html加载区别,vue中的挂载是什么意思? 将组件渲染，并且构造 DOM 元素然后塞入页面的过程称为组件的挂载。 热更新有个脱俗且有趣的解释 就是说 你的卡车开到了150KM/H 然后，有个轮胎，爆了 然后，司机说，你就直接换吧，我不停车。你小心点换 嗯。就这个意思 vue是响应式的,设计模式是observer pattern(观察者模式) 面向对象23种设计模式日常开发中常用到哪些设计模式Java笔记：SpringBoot热部署与热加载深入解析spring中用到的九种设计模式极力推荐这一篇文章设计模式的文章，举例清晰。","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"Vue","slug":"Vue","permalink":"/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"/tags/前端/"},{"name":"设计模式","slug":"设计模式","permalink":"/tags/设计模式/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]},{"title":"【转载及推荐】Vue，webpack，node之间的关系","slug":"【转载及推荐】Vue，webpack，node之间的关系","date":"2020-06-11T08:31:24.000Z","updated":"2022-03-14T05:44:18.261Z","comments":false,"path":"2020/06/11/【转载及推荐】Vue，webpack，node之间的关系/","link":"","permalink":"/2020/06/11/【转载及推荐】Vue，webpack，node之间的关系/","excerpt":"","text":"【知识】Vue，webpack，node之间的关系 vue的开发本身是不依赖node的，不过vue的脚手架工具vue-cli里面集成的webpack*是基于node开发出来的。*因此只能说webpack是依赖node的。 npm run dev本质也是起一个服务，不过是利用node起的服务，起的是前端项目的服务；两者没有联系。(你可以使用npm run命令来运行package.json文件中scripts里的任何条目) 现在的前端项目大多通过webpack管理，webpack又是基于node，node是一个运行在服务器端的js环境，浏览器本身不支持的scss、es6/es7语法、typescript等都可在node这通过工具包npm去解决.因此前端项目起的node服务一般是为了解决这些问题。 作者：Xttaoamz链接：https://www.jianshu.com/p/e4e519bec5dc来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 简书文章：webpack4入门到放弃作者：温酒居士链接：https://www.jianshu.com/p/0f4333009edd推荐原因：教程详细，步骤明了。","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"Vue","slug":"Vue","permalink":"/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"/tags/前端/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]},{"title":"Vue _ vue cli新手入门 详细解读","slug":"Vue _ vue cli新手入门 详细解读","date":"2020-05-06T04:41:24.000Z","updated":"2022-03-19T16:39:16.255Z","comments":false,"path":"2020/05/06/Vue _ vue cli新手入门 详细解读/","link":"","permalink":"/2020/05/06/Vue _ vue cli新手入门 详细解读/","excerpt":"","text":"前言本文将从vue cli项目中的入口文件入手，深入浅出地解析vue cli在开发环境下的工程的运行原理。 一、有关vue cli 3(选读）1.1 本文解析采用cli 2做示例，但原理同样适用于vue cli 3若你是cli 3开发者，参考本文时，仅需注意cli 3的三点改动： cli 3内化了项目默认配置(相关文件位于node_modules/@vue/cli-service/lib/config），开发者可通过新增vue.config.js添加webpack配置。 index.html被放到了public文件夹下 webpack配置的书写使用webpack-chain 风格 1.2 查看vue版本号、vue-cli版本号1.2.1 查看vue版本号方法一：npm ls vue方法二：package.json 1.2.1 查看vue-cli版本号 1.3 vue-cli下载最新版本卸载2.x版本的vue-cli ：npm uninstall -g vue-cli 或 yarn global remove vue-cli 安装3.x版本的@vue/cli ：npm install -g @vue/cli或 yarn global add @vue/cli 再次输入 vue -V 检验： 二、入口文件的概述 在vue cli构建的项目中，main.js是项目的入口文件，定义了vue实例，并引入根组件app.vue，将其挂载到index.html中id为app的节点上。2.1 main.js:2.1.1 两种方式：在Vue构造函数时，需要配置一个el属性但是也可以像我一样这么写2.1.2 render函数的作用render函数是vue通过js渲染dom结构的函数createElement，约定可以简写为h render: h =&gt; h(App) 缩写前 render:function(createElement){ return createElement(App); } 进一步缩写为(ES6 语法) render(createElement){ return createElement(App); } 再进一步缩写为： render(h){ return h(App) } 按照 ES6 箭头函数的写法，就得到了： h =&gt; h(App) 实际渲染 import App from &#39;./App&#39; import Vue from &#39;vue&#39; new Vue({ el:&#39;#root&#39;, template:&#39;&lt;App&gt;&lt;/App&gt;&#39;, components:{ App } }) 手动挂载 在Vue构造函数时，需要配置一个el属性，如果没有没有el属性时，可以使用.$mount(&#39;#app&#39;)进行挂载。 // 配置了el属性： new Vue({ el:&quot;#app&quot;, router }); // 如果没有配置el属性，可以使用手动挂载$mount(&quot;#app&quot;) new Vue({ router }).$mount(&#39;#app&#39;); 官方解释翻译：它来自单词 hyperscript，这个单词通常用在 virtual-dom 的实现中。Hyperscript 本身是指 生成HTML 结构的 script 脚本，因为 HTML 是 hyper-text markup language 的缩写（超文本标记语言） createElement 函数是用来生成 HTML DOM 元素的，也就是上文中的 generate HTMLstructures，也就是 Hyperscript，这样作者才把 createElement 简写成 h。 h是 Vue.js 里面的createElement 函数，这个函数的作用就是生成一个 VNode节点，render 函数得到这个 VNode 节点之后，返回给 Vue.js 的 mount 函数，渲染成真实 DOM 节点，并挂载到根节点上 注意：vue实例挂载后，会对节点原内容进行覆盖。所以，即便index.html和app.vue中都定义了&lt;div id=&quot;app&quot;&gt;&lt;/app&gt;, 最终网页也不会出现两个id为app的节点。 2.2 index.html：&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;/body&gt; 2.3 app.vue:&lt;template&gt; &lt;div id=&quot;app&quot;&gt; ..... &lt;/div&gt; &lt;/template&gt; 三、问题main.js的作用已经明了，但仍有三个疑问: main.js为什么叫入口文件，什么是“入口文件”？ 在运行npm run dev后，若不做特殊设置，index.html实际页面中仅挂载了app.js一个脚本，所有组件去哪儿了，app.js是如何形成的？ vue实例化在main.js中，但在index.html中并没有引入main.js，main.js与index.html是如何产生关联的? 四、原因：Webpackvue cli搭建的项目本质是一个集成预设置的webpack项目。是webpack驱动着项目的打包，热重载和本地运行。而上述问题都是由webpack逐一处理的： 入口文件是一个webpack概念；入口文件是webpack构建内部依赖图的起点。 app.js是由webpack打包生成的输出文件。 而将app.js挂载到index.html这一过程是由webpack的一个插件——html-webpack-plugin完成的。 4.1 什么是webpackwebpack 是JavaScript 应用程序的静态模块打包器。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图，然后将应用程序所需的所有模块打包成一个或多个 bundle。 4.2 webpack的核心作用 浏览器仅能识别html,css和js，而无法识别封装的less,vue,jsx等文件，而webpack则可以将这些文件解析打包成浏览器能识别的基本文件。 模块化开发中，我们会编写大量模块，如果不打包就上线，那么页面加载或交互时，将会发起大量资源请求。为了性能优化，需要使用webpack这样的打包器对模块进行打包整合，以减少请求数。就像简单的vue项目，所有组件最终都将被打包到一个app.js中。 相较于无差别打包依赖模块的传统打包器，webpack的核心优势在于它从入口文件出发，递归构建依赖关系图。通过这样的依赖梳理，webpack打包出的bundle不会包含重复或未使用的模块，实现了按需打包，极大的减少了冗余。 4.3 webpack配置文件 vue cli 2 在build目录下默认有三种场景配置 ——webpack.base/dev/prod.conf.jsbase是基础配置，dev/prod分别是开发和产品场景的配置，它们在merge基础配置后追加或覆盖相关配置。 const devWebpackConfig = merge(baseWebpackConfig, { // 开发环境设置 }) 在运行或打包时，会根据你的命令选择不同的配置文件。脚本配置是写在package.json中的，如npm run dev就是使用开发环境配置。 &quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;, &quot;start&quot;: &quot;npm run dev&quot;, &quot;build&quot;: &quot;node build/build.js&quot; } 一份配置包含了入口文件，输出和各种插件的配置。 4.4 vue的入口文件设置 在webpack.base/webpack.dev中，vue默认设置main.js为项目的唯一入口。在项目打包时，webpack会从main.js开始构建依赖图，梳理整个项目依赖且不重复的模块。入口配置如下： entry: { app: &#39;./src/main.js&#39; }, 4.4.1 入口设置延伸（选读） webpack的入口设置，这里不展开讲。如果你要做多页面项目，而非默认的SPA，那么你要为每个页面设置一个入口。如果你要将app与第三方库分离，也要设置两个入口。这些操作可参考webpack的官方文档 webpack官方文档https://www.webpackjs.com/concepts/entry-points/ 如果你想要封装自己的UI库，那么在入口部分的设置，你可以参考以下这篇文章。 实现element-ui的按需引入，按需打包加载 https://segmentfault.com/a/1190000015884948 4.5 输出文件配置 配置中还定义了项目的输出设定。在output中，你可以配置打包输出文件的路径，名称，进行分离js/css等操作。 // webpack.base.conf output: { path: config.build.assetsRoot, filename: &#39;[name].js&#39;, publicPath: process.env.NODE_ENV === &#39;production&#39; ? config.build.assetsPublicPath : config.dev.assetsPublicPath }, 这里只讲一下 filename 这一属性：filename定义的是输出文件的名称，[name]是webpack中的占位符，它对应entry中对象的键名。默认配置中仅有一个入口–app。所以，在默认的开发模式下，本项目的所有资源最终打包生成的文件就是app.js。注：在开发模式下，项目是跑在webpack-dev-server的虚拟服务器上，此时app.js仅存在于内存中。 4.6 HtmlWebpackPlugin配置 vue的webpack默认配置中还加入了htmlwebpackplugin插件，用于生成index.html与挂载JS脚本。配置参数中：filename是输出文件名，template是本地模板文件名，HtmlWebpackPlugin默认挂载的模板就是根目录下的index.html。inject属性定义了js脚本加载的位置，默认值true，则在body最下方加载。你还可以添加其它参数，比如网站图标favicon等，这一系列参数均可参考webpack官方文档。 new HtmlWebpackPlugin({ filename: &#39;index.html&#39;, template: &#39;index.html&#39;, inject: true, favicon:&#39;static/img/temple.png&#39; }) 五、 总结当你输入 npm run dev 后，发生了这样一连串事件：webpack选择了开发配置，并进入main.js入口文件，构建项目依赖图。webpack将整理后的所有依赖模块打包成输出文件app.js，接着htmlwebpackPlugin将它挂载到index.html页面上。最终，它呈现出的模样如下所示：","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"IDEA","slug":"IDEA","permalink":"/tags/IDEA/"},{"name":"Vue","slug":"Vue","permalink":"/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"/tags/前端/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"从零搭建考试系统——多模块的项目环境搭建（idea）","slug":"从零搭建考试系统——多模块的项目环境搭建（idea）","date":"2020-04-10T22:41:24.000Z","updated":"2022-03-14T05:32:53.244Z","comments":false,"path":"2020/04/11/从零搭建考试系统——多模块的项目环境搭建（idea）/","link":"","permalink":"/2020/04/11/从零搭建考试系统——多模块的项目环境搭建（idea）/","excerpt":"","text":"1.项目父模块创建 2.项目子模块创建","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"解决方案","slug":"解决方案","permalink":"/tags/解决方案/"},{"name":"IDEA","slug":"IDEA","permalink":"/tags/IDEA/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"大学生活","slug":"daxueshenghuo","date":"2019-12-12T14:16:01.000Z","updated":"2022-03-12T11:20:33.937Z","comments":true,"path":"2019/12/12/daxueshenghuo/","link":"","permalink":"/2019/12/12/daxueshenghuo/","excerpt":"","text":"大学时的军训第一天 下起了小雨，只好收编返回宿舍，得劲儿 在当时手里没有优盘，临时拼凑起来一个 记一次冬至来临，作为寝室长特意提议大伙儿小聚小餐一顿 还有许多有趣的记录，有空再传嘞…","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"生活","slug":"生活","permalink":"/tags/生活/"},{"name":"图集","slug":"图集","permalink":"/tags/图集/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"哔哩哔哩外链插入","slug":"bibilink","date":"2019-12-12T14:16:01.000Z","updated":"2022-03-11T09:51:19.184Z","comments":true,"path":"2019/12/12/bibilink/","link":"","permalink":"/2019/12/12/bibilink/","excerpt":"","text":"hexo-tag-bili在Hexo博客文章或者单页面中加入样式优美bilibili外链播放器。 语法:{% bili video_id %} 或 {% bili video_id page %} 使用方式在Hexo博客目录使用npm安装插件 npm i hexo-tag-bili –save在Hexo博客的文章或者单页面中使用以下标签语法插入视频 {% bili video_id %} 或 {% bili video_id page %} 例子:如果视频网址如：https://www.bilibili.com/video/av24897960 在文章中插入的标签语法为：{% bili 24897960 %} 如果视频网址如（第二页）：https://www.bilibili.com/video/av24897960/?p=2 在文章中插入的标签语法为：{% bili 24897960 2 %}","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"life","slug":"life","date":"2019-12-12T14:16:01.000Z","updated":"2022-03-11T08:56:38.798Z","comments":true,"path":"2019/12/12/life/","link":"","permalink":"/2019/12/12/life/","excerpt":"","text":"我当时的初中学校大门（旧貌） 还走了一段时间的后门，不过后来前面已经改建、翻新 这是在我家里收拾旧东西看到的，当时被一直延用下来ps:我可是语文第二任语文课代表啊! 对于母校回忆，还有更难忘的，那就是我所参与的抖空竹、篆刻、象棋竞赛等等。常常因为篆刻作品，弄到深夜 还有许多有趣的回忆，暂不赘述。你的母校现在怎么样了？","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"生活","slug":"生活","permalink":"/tags/生活/"},{"name":"图集","slug":"图集","permalink":"/tags/图集/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]}]}