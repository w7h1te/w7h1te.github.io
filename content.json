{"meta":{"title":"w7h1te","subtitle":null,"description":"w7h1te的个人博客","author":"w7h1te","url":""},"pages":[{"title":"bangumi","date":"2020-02-10T13:32:48.000Z","updated":"2022-03-30T05:29:56.318Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2020-12-20T15:13:35.000Z","updated":"2022-03-10T23:31:06.130Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"该功能还在开发中…….","keywords":"Android客户端"},{"title":"","date":"2022-03-11T01:14:10.273Z","updated":"2022-03-11T01:14:10.273Z","comments":true,"path":"cloud/index.html","permalink":"/cloud/index.html","excerpt":"","text":"layout: cloudtitle: clouddate: 2022-03-11 09:09:06keywords: 资源description:comments: truephotos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg"},{"title":"about","date":"2020-12-12T14:14:36.000Z","updated":"2022-03-10T06:10:06.698Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[w7h1te的专属聊天室] w7h1te 正在与&nbsp; w7h1te&nbsp; （ ） 对话中... 对方正在输入... bot_ui_ini()","keywords":"关于"},{"title":"comment","date":"2020-12-20T15:13:48.000Z","updated":"2022-03-09T11:26:54.032Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2020-12-20T15:13:05.000Z","updated":"2022-03-09T11:26:54.142Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2020-01-05T13:47:59.000Z","updated":"2022-03-09T11:26:54.056Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2020-12-19T15:11:06.000Z","updated":"2022-03-09T11:26:54.062Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"","date":"2022-03-11T01:12:02.545Z","updated":"2022-03-11T01:12:02.545Z","comments":true,"path":"idea/index.html","permalink":"/idea/index.html","excerpt":"","text":"layout: ideatitle: ideadate: 2022-03-11 09:09:06keywords: 随想description:comments: truephotos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg"},{"title":"","date":"2022-03-11T01:11:14.291Z","updated":"2022-03-11T01:11:14.291Z","comments":true,"path":"live/index.html","permalink":"/live/index.html","excerpt":"","text":"layout: livetitle: livedate: 2022-03-11 09:09:06keywords: 生活description:comments: truephotos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg"},{"title":"music","date":"2020-12-20T15:14:28.000Z","updated":"2022-03-09T11:26:54.048Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2020-12-20T15:09:03.000Z","updated":"2022-03-09T11:26:54.126Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"","date":"2022-03-11T01:14:10.273Z","updated":"2022-03-11T01:14:10.273Z","comments":true,"path":"reprint/index.html","permalink":"/reprint/index.html","excerpt":"","text":"layout: reprinttitle: reprintdate: 2022-03-11 09:09:06keywords: 转载description:comments: truephotos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg"},{"title":"theme-sakura","date":"2022-03-09T14:53:25.000Z","updated":"2022-03-09T11:09:34.805Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"tags","date":"2020-12-12T14:14:16.000Z","updated":"2022-03-10T08:11:18.034Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2022-03-10T10:54:29.517Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://tvax3.sinaimg.cn/large/008kBpBlgy1gwn5ssbgp2j307409wmxs.jpg', title: '进击的巨人 最终季 Part.2', status: '追更中', progress: 70, jp: '進撃の巨人 The Final Season Part.2', time: '首播时间：2022-01-09', desc: ' 在艾伦他们居住的帕拉迪岛之外，还存在一个其他人类居住的世界。当中一个国家「玛雷」与其他各国爆发战争。陷入苦战之际，他们决定要攻进帕拉迪岛，把「始祖的巨人」抢过来。在这里又看到另一群孩子们拼命求生存的身影……。' }, { img : 'https://tvax3.sinaimg.cn/large/008kBpBlgy1gwengmvxr3j307409wdgi.jpg', title: '进击的巨人 最终季 Part.2', status: '追更中', progress: 70, jp: '進撃の巨人 The Final Season Part.2', time: '首播时间：2022-01-09', desc: ' 在艾伦他们居住的帕拉迪岛之外，还存在一个其他人类居住的世界。当中一个国家「玛雷」与其他各国爆发战争。陷入苦战之际，他们决定要攻进帕拉迪岛，把「始祖的巨人」抢过来。在这里又看到另一群孩子们拼命求生存的身影……。' }, { img : 'https://tvax3.sinaimg.cn/large/008kBpBlgy1gwn5ssbgp2j307409wmxs.jpg', title: '进击的巨人 最终季 Part.2', status: '追更中', progress: 70, jp: '進撃の巨人 The Final Season Part.2', time: '首播时间：2022-01-09', desc: ' 在艾伦他们居住的帕拉迪岛之外，还存在一个其他人类居住的世界。当中一个国家「玛雷」与其他各国爆发战争。陷入苦战之际，他们决定要攻进帕拉迪岛，把「始祖的巨人」抢过来。在这里又看到另一群孩子们拼命求生存的身影……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"【后端实现发送Post请求】在SpringBoot下，以Content-Type_application_json示例","slug":"【后端实现发送Post请求】在SpringBoot下，以Content-Type_application_json示例","date":"2022-06-30T22:31:53.000Z","updated":"2022-07-06T23:40:52.961Z","comments":false,"path":"2022/07/01/【后端实现发送Post请求】在SpringBoot下，以Content-Type_application_json示例/","link":"","permalink":"/2022/07/01/【后端实现发送Post请求】在SpringBoot下，以Content-Type_application_json示例/","excerpt":"","text":"业务背景：最近在实现微信授权登陆，并且获取授权用户的手机号码，其中是需要我们后台写工具类来模拟对接口的调用来取得相应参数，其实就是相当于实现PostMan、AirPost之类的工具对后端接口发起请求的功能，本篇是以Post的请求方式，参数以JSON格式封装在请求体中，请求头为application/json，进行示例模拟。关于获取微信授权数据的相关文章会在后续写出（先给自己挖个坑）。 一、导入依赖 &lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.24&lt;/version&gt; &lt;/dependency&gt; 二、实现代码package user; import com.alibaba.fastjson.JSONObject; import org.apache.http.client.methods.CloseableHttpResponse; import org.apache.http.client.methods.HttpPost; import org.apache.http.entity.ContentType; import org.apache.http.entity.StringEntity; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClients; import org.apache.http.util.EntityUtils; import org.junit.Test; import java.io.IOException; /** * @author w7h1te * @version 6月... * @date 2022/6/30 11:31 */ public class UserTrain { /*** * 在咱们平常作项目的时候，有时候不免会接触到HttpClient进行一些数据的请求和传输。HttpClient默认使用的是表单提交的形式进行数据post， * 有时候咱们须要使用json或者其余形式发送数据那么咱们就须要修改他的content-typejson */ @Test public void testPostRequest() { //咳咳，接口地址还是要隐藏的，一个登陆接口的测试 String url = &quot;http://*****:8080/***/***/login&quot;; //请求体，随便放两个参 JSONObject parammap = new JSONObject(); parammap.put(&quot;userName&quot;, &quot;1371606161111&quot;); parammap.put(&quot;passWord&quot;,&quot;12332211&quot;); String str = doPost(url, parammap.toJSONString()); // 输出响应内容 System.out.println(str); } public String doPost(String url ,String json) { // 建立Httpclient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); CloseableHttpResponse response = null; String res = &quot;&quot;; try { // 建立Http Post请求 HttpPost post = new HttpPost(url); // 建立请求内容 ContentType：请求格式设置 StringEntity entity = new StringEntity(json, ContentType.APPLICATION_JSON); post.setEntity(entity); // 执行http请求 response = httpClient.execute(post); res = EntityUtils.toString(response.getEntity(), &quot;utf-8&quot;); } catch (IOException e) { e.printStackTrace(); } finally { try { if (response != null) { response.close(); } } catch (IOException e) { e.printStackTrace(); } } return res; } } 执行结果{&quot;success&quot;:false,&quot;resultCode&quot;:&quot;-1&quot;,&quot;resultMsg&quot;:&quot;用户名和密码不匹配,请您检查后重新登录&quot;,&quot;data&quot;:null} 三、使用我们的AirPost再次做个测试直接上图来点真实的可以看到，这个返回结果是走了我们的后台逻辑判断的，请求是成功的。 四、注意可以看到我们是请求成功的，当然这里面还是有很多点值得注意的。 4.1 第一点：参数传输问题Content-Type:application/json这样的请求格式，可以在上面AirPost中看到，传入的参数是以json的格式，那么我们相应的后台接收应该是 以method(@RequestBody VO index)的方式来接收，否则是接收不到的。 4.2 第二点：关于ContentTypeHTTP/1.1 协议规定的 HTTP 请求方法有 OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT 这几种。其中 POST 一般用来向服务端提交数据，本文主要讨论 POST 提交数据的几种方式。 我们知道，HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。协议规定 POST 提交的数据必须放在消息主体（entity-body）中，但协议并没有规定数据必须使用什么编码方式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。 服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。所以说到 POST 提交数据方案，包含了 Content-Type 和消息主体编码方式两部分。| | 前端 Content-Type | 后端 ContentType |json对象/字符串 |后端参数获取形式 ||:——–:|:——–:|:——–:|:——–:|:——–:|| 1 |application/json |APPLICATION_JSON | 字符串 | method(@RequestBody VO index) || 2 | appcalition/www-form-urlencode |APPLICATION_FORM_URLENCODED | 对象 | method(VO index) | 4.3 第三点：获取参数的几种常用注解@PathVariable：一般我们使用URI template样式映射使用，即url/{param}这种形式，也就是一般我们使用的GET，DELETE，PUT方法会使用到的，我们可以获取URL后所跟的参数。@RequestParam：一般我们使用该注解来获取多个参数，在（）内写入需要获取参数的参数名即可，一般在PUT，POST中比较常用。@RequestBody：该注解和@RequestParam殊途同归，我们使用该注解将所有参数转换，在代码部分在一个个取出来，也是目前我使用到最多的注解来获取参数@RequestHeader来获取头信息里的值，@CookieValue来获取Cookie值等等。在这，我也仅仅说明一些较常用的取值方法而已。 五、*引申扩展（文章推荐）Json对象和Json字符串的区别SpringBoot实现前后端、json数据交互以及Controller接收参数的几种常用方式java分别发送post请求applicationx-www-form-urlencoded和applicationjson类型数据HTTP Content-Type","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"前端","slug":"前端","permalink":"/tags/前端/"},{"name":"后端","slug":"后端","permalink":"/tags/后端/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"【SVN】解决提交代码冲突","slug":"【SVN】解决提交代码冲突","date":"2022-06-29T14:35:09.000Z","updated":"2022-06-30T22:25:31.790Z","comments":false,"path":"2022/06/29/【SVN】解决提交代码冲突/","link":"","permalink":"/2022/06/29/【SVN】解决提交代码冲突/","excerpt":"","text":"问题背景：合作开发项目，在服务器上已经有一个基础版本代码后，两个人先后提交代码，并且没有互相通知更新代码，己方开发完成，执行更新命令，提示冲突。这其实并不可怕，拉下来在idea里面其实是有窗口提示的，这边点个叉 目前代码如下 这边依次是多了三个文件，并且本地提交文件变成未提交状态。这时候如果直接提交是提交不上去的。这三个文件依次为：mine：己方变更的文件版本36782（svn给的编号）：是基础版本，即两方修改之前的基础版本36805（svn给的编号）：服务器版本，即另一方做修改后的版本 然后我们本地文件变成图一样式：这是提示我们的冲突标识，不必在意按如下步骤依次操作：这里是对当前版本文件进行编辑，我们点击合并接下来点击这个黄色框子里边的箭头，依次将代码放到中间这个需要提交的版本上，做合并操作点击应用只需要重新提交即可！其他的代码操作同上！即可在idea里面解决版本冲突问题。 对了，补充一下：除了使用自动的箭头识别，手动复制粘贴也不失为一种好办法","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"SVN","slug":"SVN","permalink":"/tags/SVN/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"【关于工具类的使用】中文拼音首字母转换为大写","slug":"【关于工具类的使用】中文拼音首字母转换为大写","date":"2022-06-25T01:25:36.000Z","updated":"2022-06-29T23:58:52.861Z","comments":false,"path":"2022/06/25/【关于工具类的使用】中文拼音首字母转换为大写/","link":"","permalink":"/2022/06/25/【关于工具类的使用】中文拼音首字母转换为大写/","excerpt":"","text":"业务场景：在我们实际业务开发中，会遇到生成较为开放类型的活动编号等，有对应的生成规则，比如需要将当前参与用户人名的中文拼音的首字母大小写取到，在加上时间戳信息等等。这里应用到一个解决方案。 1、导入相应的依赖 &lt;dependency&gt; &lt;groupId&gt;com.belerweb&lt;/groupId&gt; &lt;artifactId&gt;pinyin4j&lt;/artifactId&gt; &lt;version&gt;2.5.0&lt;/version&gt; &lt;/dependency&gt; 2、实现的工具类代码 public String toFirstChar(String chinese){ String pinyinStr = &quot;&quot;; char[] newChar = chinese.toCharArray(); //转为单个字符 HanyuPinyinOutputFormat defaultFormat = new HanyuPinyinOutputFormat(); defaultFormat.setCaseType(HanyuPinyinCaseType.UPPERCASE); defaultFormat.setToneType(HanyuPinyinToneType.WITHOUT_TONE); for (int i = 0; i &lt; newChar.length; i++) { if (newChar[i] &gt; 128) { try { pinyinStr += PinyinHelper.toHanyuPinyinStringArray(newChar[i], defaultFormat)[0].charAt(0); } catch (BadHanyuPinyinOutputFormatCombination e) { log.error(e); } }else{ pinyinStr += newChar[i]; } } return pinyinStr; } public static void main(String[] args) { TalentNewServiceImpl tt =new TalentNewServiceImpl(); String target = tt.toFirstChar(&quot;张三san1233&quot;); System.out.println(&quot;生成的活动名称首字母大写:&quot;+&quot; &quot;+target); } // 生成的活动名称首字母大写: ZSsan1233 3、介绍HanyuPinyinOutputFormat defaultFormat = new HanyuPinyinOutputFormat(); // 控制大小写 // UPPERCASE：大写 (ZHONG) // LOWERCASE：小写 (zhong) defaultFormat.setCaseType(HanyuPinyinCaseType.UPPERCASE); // WITHOUT_TONE：无音标 (zhong) // WITH_TONE_NUMBER：1-4数字表示英标 (zhong4) // WITH_TONE_MARK：直接用音标符（必须WITH_U_UNICODE否则异常） (zhòng) defaultFormat.setToneType(HanyuPinyinToneType.WITH_TONE_NUMBER); // WITH_V：用v表示ü (nv) // WITH_U_AND_COLON：用&quot;u:&quot;表示ü (nu:) // WITH_U_UNICODE：直接用ü (nü) defaultFormat.setVCharType(HanyuPinyinVCharType.WITH_U_UNICODE); // oHanyuPinyinStringArray如果传入的字符不是汉字不能转换成拼音，那么会直接返回null。 String[] pinyin = PinyinHelper.toHanyuPinyinStringArray(&#39;重&#39;, defaultFormat); for(String str: pinyin){ System.out.println(str); } 4、参考Java汉字转拼音pinyin4j用法详解","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"解决方案","slug":"解决方案","permalink":"/tags/解决方案/"},{"name":"JAVA","slug":"JAVA","permalink":"/tags/JAVA/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"【BigDecimal】Java在java.math包中提供的API类场景使用","slug":"【BigDecimal】Java在java.math包中提供的API类场景使用","date":"2022-06-15T23:57:44.000Z","updated":"2022-06-24T00:01:07.077Z","comments":false,"path":"2022/06/16/【BigDecimal】Java在java.math包中提供的API类场景使用/","link":"","permalink":"/2022/06/16/【BigDecimal】Java在java.math包中提供的API类场景使用/","excerpt":"","text":"最近在做统计类的业务时，遇到一个求所占百分比的数据，并且要求保留两位小数，缺0补0 ，顺便记录学习BigDecimal的过程 代码如下： public void rate() { String rate = String.valueOf(new BigDecimal(&quot;50&quot;) .divide(new BigDecimal(Integer.valueOf(&quot;50&quot;) + Integer.valueOf(&quot;4&quot;)), 4, BigDecimal.ROUND_HALF_UP) .multiply(new BigDecimal(&quot;100&quot;)).doubleValue()); System.out.println(rate);//输出结果为 92.59 但并没完全实现 } 一、简单介绍BigDecimal，用来对超过16位有效位的数进行精确的运算。双精度浮点型变量double可以处理16位有效数。在实际应用中，需要对更大或者更小的数进行运算和处理。float和double只能用来做科学计算或者是工程计算，在商业计算中要用java.math.BigDecimal。BigDecimal所创建的是对象，我们不能使用传统的+、-、*、/等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。方法中的参数也必须是BigDecimal的对象。构造器是类的特殊方法，专门用来创建对象，特别是带有参数的对象。 在我们的日常计算中，有时会涉及到比较大的数字之间的计算(如:超大金额的计算)，这时，使用float、double这样的浮点数就不那么准确了。因为不论是float 还是double都是浮点数，而计算机是二进制的，浮点数会失去一定的精确度。注：根本原因是：十进制值通常没有完全相同的二进制表示形式；十进制数的二进制表示形式可能不精确。 二、使用方法BigDecimal.setScale()方法用于格式化小数点setScale(1)表示保留一位小数，默认用四舍五入方式setScale(1,BigDecimal.ROUND_DOWN)直接删除多余的小数位，如2.35会变成2.3setScale(1,BigDecimal.ROUND_UP)进位处理，2.35变成2.4setScale(1,BigDecimal.ROUND_HALF_UP)四舍五入，2.35变成2.4setScaler(1,BigDecimal.ROUND_HALF_DOWN)四舍五入，2.35变成2.3，如果是5则向下舍setScaler(1,BigDecimal.ROUND_CEILING)接近正无穷大的舍入setScaler(1,BigDecimal.ROUND_FLOOR)接近负无穷大的舍入，数字&gt;0和ROUND_UP作用一样，数字&lt;0和ROUND_DOWN作用一样 setScaler(1,BigDecimal.ROUND_HALF_EVEN)向最接近的数字舍入，如果与两个相邻数字的距离相等，则向相邻的偶数舍入。 注释：1：scale指的是你小数点后的位数。比如123.456则score就是3.score()就是BigDecimal类中的方法。比如:BigDecimal b = new BigDecimal(“123.456”);b.scale(),返回的就是3.2：roundingMode是小数的保留模式。它们都是BigDecimal中的常量字段,有很多种。比如：BigDecimal.ROUND_HALF_UP表示的就是4舍5入。3：pubilc BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)的意思是说：我用一个BigDecimal对象除以divisor后的结果，并且要求这个结果保留有scale个小数位，roundingMode表示的就是保留模式是什么，舍入条件可以选择对应参数！ 4：小数位格式化使用如下： BigDecimal mData = new BigDecimal(&quot;5.556&quot;).setScale(2, BigDecimal.ROUND_HALF_UP); System.out.println(&quot;mData=&quot; + mData);//mData=5.56 DecimalFormat df = new DecimalFormat(&quot;###.##&quot;); BigDecimal b1 = new BigDecimal(&quot;28.0109&quot;); BigDecimal b2 = new BigDecimal(&quot;28.00&quot;); System.out.println(&quot;小数格式化：&quot; + df.format(b1));//小数格式化：28.01 System.out.println(&quot;整数格式化：&quot; + df.format(b2));//整数格式化：28 三、文中一开始遇到的问题想要去除末位0，尝试如下： String waterRate = String.valueOf(new BigDecimal(&quot;50&quot;) .divide(new BigDecimal(Long.valueOf(&quot;40&quot;) + Long.valueOf(&quot;50&quot;)), 4, ROUND_HALF_UP) .multiply(new BigDecimal(&quot;100&quot;))); System.out.println(waterRate);//55.5600 String waterRate = String.valueOf(new BigDecimal(&quot;50&quot;) .divide(new BigDecimal(Long.valueOf(&quot;40&quot;) + Long.valueOf(&quot;50&quot;)), 2, ROUND_HALF_UP) .multiply(new BigDecimal(&quot;100&quot;))); System.out.println(waterRate);//56.00 String waterRate = String.valueOf(new BigDecimal(&quot;50&quot;) .divide(new BigDecimal(Long.valueOf(&quot;40&quot;) + Long.valueOf(&quot;50&quot;)), 4, ROUND_HALF_UP) .multiply(new BigDecimal(&quot;100&quot;)).floatValue()); System.out.println(waterRate);//55.56 //floatValue() 或者 doubleValue() String waterRate = String.valueOf(new BigDecimal(&quot;50&quot;) .divide(new BigDecimal(Long.valueOf(&quot;40&quot;) + Long.valueOf(&quot;50&quot;)), 4, ROUND_HALF_UP) .multiply(new BigDecimal(&quot;100&quot;)).doubleValue()); System.out.println(waterRate);//55.56 两者都达到了预期结果 但是计算3/10 结果为30.0 少补了一位0 1、二者精度不同，对比两个小数的大小要用doubleValue2、string转浮点数，也要用doubleValue，否则不准确 使用去除末位0的方法 String waterRate = String.valueOf(new BigDecimal(&quot;50&quot;) .divide(new BigDecimal(Long.valueOf(&quot;40&quot;) + Long.valueOf(&quot;50&quot;)), 4, ROUND_HALF_UP) .multiply(new BigDecimal(&quot;100.000&quot;)).stripTrailingZeros()); System.out.println(waterRate);//55.56 使用去除末位零的方法 但是 当我测试： String waterRate = String.valueOf(new BigDecimal(&quot;30&quot;) .divide(new BigDecimal(Long.valueOf(&quot;90&quot;) + Long.valueOf(&quot;10&quot;)), 4, ROUND_HALF_UP) .multiply(new BigDecimal(&quot;100&quot;)).stripTrailingZeros()); System.out.println(waterRate);//输出结果：3E+1 显然不是很符合业务逻辑 最终还是得依靠格式转换实现 DecimalFormat df1 = new DecimalFormat(&quot;0.00%&quot;); String waterRate = String.valueOf(new BigDecimal(&quot;31.1&quot;) .divide(new BigDecimal(Long.valueOf(&quot;90&quot;) + Long.valueOf(&quot;10&quot;)), 4, ROUND_HALF_UP)); Double rate= Double.valueOf(waterRate); System.out.println(df1.format(rate));//输出结果：31.10% 实现了缺0补0 四、文章相关参考及引申：1.简单理解BigDecimal.valueof(Double t)与BigDecimal.valueof(String t)的区别——BigDecimal2.BigDecimal基本知识3.浮点型变量(float和double)和BigDecimal的使用4.在Java中涉及到交易和金融货币的时候为什么不能用double、float来计算？使用BigDecimal解决5.饿了么技术专家总结之——double与BigDecimal使用姿势 其他2：关于Mysql中如何选用double、BigDecimal两种类型1.首先与java不同的是mysql是用来持久化数据的，而java中使用的数据一般更多的是过一下内存； 2.数据库都要除了指定数据类型指外还需要指定精度，因此在DB中Double计算时精度的丢失比Java高得多； 因为Java默认精确到15-16位了； 3.更改数据类型的成本，Mysql比Java代码要难得多； 考虑到以上与java中不同几点，做点个人使用总结： 1.与商业金融相关字段要使用Decimal来表示，如金额，费率等字段； 2.参与各类计算如加，减，乘，除,sum,avg等等，也要使用Decimal； 3.经纬度，可以使用double来表示，这个可参考Java，只要保证精度范围即可； 4.如果确实不确定使用什么double或Decimal哪种类型合适，那最好使用Decimal，毕竟稳定，安全高于一切； 注：阿里的编码规范中强调统一带小数的类型一律使用Decimal类型，也是有道理的，使用Decimal可以大大减少计算踩坑的概率","categories":[{"name":"原创","slug":"原创","permalink":"/categories/原创/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"JAVA","slug":"JAVA","permalink":"/tags/JAVA/"},{"name":"后端","slug":"后端","permalink":"/tags/后端/"}],"keywords":[{"name":"原创","slug":"原创","permalink":"/categories/原创/"}]},{"title":"【MySQL】关于日期相关的函数操作","slug":"【MySQL】关于日期相关的函数操作","date":"2022-05-24T04:28:47.000Z","updated":"2022-06-23T23:46:30.008Z","comments":false,"path":"2022/05/24/【MySQL】关于日期相关的函数操作/","link":"","permalink":"/2022/05/24/【MySQL】关于日期相关的函数操作/","excerpt":"","text":"业务场景：出现于在做可视化、报表相关的接口时，我们需要接收前端的一个时间参数或者是默认当前的时间，前半年数据查询或者是求总和之类的。本篇主要想分享一些关于日期计算、转换的方法，后面会写一篇探讨如何优化的文章。 一、 date_format(date, format)date是需要转化的日期数据，format定义的是转换格式。例如： SELECT DATE_FORMAT(&#39;2000.6.1&#39;,&#39;%y-%m-%d %W&#39;) 还可以这样： SELECT DATE_FORMAT(&#39;2000.6.1&#39;,&#39;%Y年%m月%d日&#39;) SELECT DATE_FORMAT(&#39;2000.6.8&#39;,&#39;%h%时-%m%分-%s%秒&#39;) 二、str_to_date(str,format)str是需要转换的字符串数据，format定义的是转换格式即DATETIME类型的值，例如：注意：str的格式需要和format的格式保持一致，否则结果为null； SELECT STR_TO_DATE(&#39;2000-06-01 10:20:30&#39;,&#39;%Y-%m-%d&#39;) SELECT STR_TO_DATE(&#39;2000-06-01 10:20:30&#39;,&#39;%Y-%m-%d %H:%i:%s&#39;) 三、format包含的格式 格式 描述 %a 缩写星期名 %b 缩写月名 %c 月，数值 %D 带有英文前缀的月中的天 %d 月的天，数值(00-31) %e 月的天，数值(0-31) %f 微秒 %H 小时 (00-23) %h 小时 (01-12) %I 小时 (01-12) %i 分钟，数值(00-59) %j 年的天 (001-366) %k 小时 (0-23) %l 小时 (1-12) %M 月名 %m 月，数值(00-12) %p AM 或 PM %r 时间，12-小时（hh:mm:ss AM 或 PM） %S 秒(00-59) %s 秒(00-59) %T 时间, 24-小时 (hh:mm:ss) %U 周 (00-53) 星期日是一周的第一天 %u 周 (00-53) 星期一是一周的第一天 %V 周 (01-53) 星期日是一周的第一天，与 %X 使用 %v 周 (01-53) 星期一是一周的第一天，与 %x 使用 %W 星期名 %w 周的天 （0=星期日, 6=星期六） %X 年，其中的星期日是周的第一天，4 位，与 %V 使用 %x 年，其中的星期一是周的第一天，4 位，与 %v 使用 %Y 年，4 位 %y 年，2 位 %文字 展示文字，%文字 上面部分截选自 https://blog.csdn.net/qq_45844443/article/details/120936965 四、unix_timestamp(date) 函数将时间转换为时间戳，如果参数为空，则处理的是当前的时间（返回从’1970-01-01 00:00:00’GMT开始的到当前时间的秒数，不为空则它返回从’1970-01-01 00:00:00’ GMT开始的到指定date的秒数值），date可以是一个DATE字符串、一个DATETIME字符串、一个TIMESTAMP或以YYMMDD或YYYYMMDD格式的本地时间的一个数字。例： SELECT (SELECT UNIX_TIMESTAMP()) AS a,(SELECT UNIX_TIMESTAMP(NOW()))AS b SELECT UNIX_TIMESTAMP(&#39;2022/06/01 10/20/30&#39;) AS a SELECT UNIX_TIMESTAMP(&#39;10/20/30&#39;) AS b SELECT UNIX_TIMESTAMP(&#39;1900/12/29 10:20:30&#39;) AS c 五、from_unixtime(unix_timestamp, format) 函数MySQL时间戳格式化函数from_unixtime SELECT FROM_UNIXTIME(1654050030,&#39;%Y-%m-%d %H:%i:%s %W&#39;); 六、 current_time，current_date()与now()区别current_date()只显示的是当前时间的日期例如： SELECT CURRENT_DATE() 结果：2022-05-24 current_time()只显示当前时间的时分秒例如： SELECT CURRENT_TIME() 11:32:35 now（）显示全部例如： SELECT NOW() 结果：2022-05-24 11:33:11 在增加减少日期时current_time，current_date()类似与now()不同详细如下:CURRENT_DATE()函数 #获取当前日期 SELECT CURRENT_DATE() AS newDate; #2022-05-24 #当前日期加1天（其他天数方法一样） SELECT DATE_ADD(CURRENT_DATE(), INTERVAL 1 DAY) AS newDate; #2022-05-25 #当前日期减1天 SELECT DATE_ADD(CURRENT_DATE(), INTERVAL -1 DAY) AS newDate; #2022-05-23 SELECT DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY) AS newDate; #2022-05-23 #当前日期加1个月 SELECT DATE_SUB(CURRENT_DATE(), INTERVAL -1 MONTH) AS newDate; #2022-06-24 #当前日期减1个月 SELECT DATE_ADD(CURRENT_DATE(), INTERVAL -1 MONTH) AS newDate; #2022-04-24 #当前日期加1年 SELECT DATE_ADD(CURRENT_DATE(), INTERVAL 1 YEAR) AS newDate; #2023-05-24 #当前日期减1年 SELECT DATE_SUB(CURRENT_DATE(), INTERVAL 1 YEAR) AS newDate; #2021-05-24 #指定日期加1天（可将DAY换为MONTH,YEAR来实现加1个月,1年） SELECT DATE_ADD(&#39;2022-05-20&#39;, INTERVAL 1 DAY) AS newDate; #2022-05-21 #指定日期减1月 SELECT DATE_SUB(&#39;2022-05-21&#39;, INTERVAL 1 MONTH) AS newDate; #2022-04-21 #当前时间添加1小时10分钟10秒钟 SELECT DATE_ADD(NOW(), INTERVAL &#39;1:10:10&#39; HOUR_SECOND) AS newTime; #2022-05-24 12:51:45 #指定时间添加1年10个月 SELECT DATE_ADD(&#39;2019-04-17 2:00:00&#39;, INTERVAL &#39;1:10&#39; YEAR_MONTH) AS newTime; #2021-02-17 02:00:00 NOW()函数 #获取当前时间 SELECT NOW() AS newTime; #当前时间减30秒 SELECT (NOW() - INTERVAL 30 SECOND) AS newTime; #当前时间加30秒 SELECT (NOW() + INTERVAL 30 SECOND) AS newTime; #当前时间减30分钟 SELECT (NOW() - INTERVAL 30 MINUTE) AS newTime; #当前时间加30分钟 SELECT (NOW() + INTERVAL 30 MINUTE) AS newTime; #当前时间减1天 SELECT (NOW() - INTERVAL 1 DAY) AS newTime; #当前时间加1天 SELECT (NOW() + INTERVAL 1 DAY) AS newTime; #当前时间减1个月 SELECT (NOW() - INTERVAL 1 MONTH) AS newTime; #当前时间加1个月 SELECT (NOW() + INTERVAL 1 MONTH) AS newTime; #当前时间减1年 SELECT (NOW() - INTERVAL 1 YEAR) AS newTime; #当前时间加1年 SELECT (NOW() + INTERVAL 1 MONTH) AS newTime; #指定时间的加减，将上面的NOW()函数换为指定日期时间即可，以加30分钟为例，如下: SELECT (&#39;2022-05-20 12:30:00&#39; + INTERVAL 30 MINUTE) AS newTime; #2022-05-20 13:00:00 本文部分截选自 https://blog.csdn.net/weixin_47343544/article/details/119910041，如有侵权，请联系删除。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"Mysql","slug":"Mysql","permalink":"/tags/Mysql/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"【字符串截取】String类下的字符串内容截取手段","slug":"关于String类下的字符串内容截取手段","date":"2022-05-03T01:32:53.000Z","updated":"2022-06-24T00:03:23.719Z","comments":false,"path":"2022/05/03/关于String类下的字符串内容截取手段/","link":"","permalink":"/2022/05/03/关于String类下的字符串内容截取手段/","excerpt":"","text":"业务小场景：截取指定输入内容的某个特殊符号前的字符串，比如 要求输入 张三_1371606XXXX这么一个格式，我们要截取他的姓名，于是就引出了下面这篇文章 public static void main(String[] args) { String st = &quot;sss--xxx&quot;; System.out.println(&quot;substring&quot; + &quot;返回从索引0开始,第一次出现字符串ss的全部字符串：&quot;+st.substring(0, st.indexOf(&quot;-&quot;))); System.out.println(&quot;indexOf&quot; + &quot;返回从索引1开始的字符串ss的结束索引位置：&quot;+st.indexOf(&quot;ss&quot;,1)); System.out.println(&quot;indexOf&quot; + &quot;返回最小索引值(int)，未找到则返回-1：&quot;+st.indexOf(&quot;z&quot;)); }","categories":[{"name":"原创","slug":"原创","permalink":"/categories/原创/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"JAVA","slug":"JAVA","permalink":"/tags/JAVA/"},{"name":"后端","slug":"后端","permalink":"/tags/后端/"}],"keywords":[{"name":"原创","slug":"原创","permalink":"/categories/原创/"}]},{"title":"【JVM】类加载——双亲委派机制","slug":"【JVM】类加载——双亲委派机制","date":"2022-04-21T12:35:02.000Z","updated":"2022-04-21T15:11:20.163Z","comments":false,"path":"2022/04/21/【JVM】类加载——双亲委派机制/","link":"","permalink":"/2022/04/21/【JVM】类加载——双亲委派机制/","excerpt":"","text":"在面试过程中：也会被问到关于如何理解双亲委派模型这样的问题，接下来就通过这篇文章往明白了解一下。 我们首先需要了解一下类加载阶段 类的加载阶段类加载阶段分为加载、连接、初始化三个阶段，而加载阶段需要通过类的全限定名来获取定义了此类的二进制字节流。Java特意把这一步抽出来用类加载器来实现。把这一步骤抽离出来使得应用程序可以按需自定义类加载器。并且得益于类加载器，OSGI、热部署等领域才得以在JAVA中得到应用。 类加载器除了能用来加载类，还能用来作为类的层次划分。Java自身提供了3种类加载器 类加载器1、启动类加载器(Bootstrap ClassLoader),它是属于虚拟机自身的一部分，用C++实现的，主要负责加载&lt;JAVA_HOME&gt;\\lib目录中或被-Xbootclasspath指定的路径中的并且文件名是被虚拟机识别的文件。它等于是所有类加载器的爸爸。 2、扩展类加载器(Extension ClassLoader),它是Java实现的，独立于虚拟机，主要负责加载&lt;JAVA_HOME&gt;\\lib\\ext目录中或被java.ext.dirs系统变量所指定的路径的类库。 3、应用程序类加载器(Application ClassLoader),它是Java实现的，独立于虚拟机。主要负责加载用户类路径(classPath)上的类库，如果我们没有实现自定义的类加载器那这玩意就是我们程序中的默认加载器。 什么是双亲委派机制上图： 简单来说：如果一个类加载器需要加载类，那么首先它会把这个类请求委派给父类加载器去完成，每一层都是如此。一直递归到顶层，当父加载器无法完成这个请求时，子类才会尝试去加载。这里的双亲其实就指的是父类，没有mother。父类也不是我们平日所说的那种继承关系，只是调用逻辑是这样。 也就是当类加载器收到类加载的请求时候会首先调用父类（ClassLoader）的findLoadedClass方法，判断类是否加载过，如果已经加载过则直接返回，否则会将加载任务委托给成员变量parent，并不是指的父类。parent加载器在收到类加载请求后，也会先判断需要加载的类是否已经加载过，如果加载过则结束，否则也会将加载任务委托给成员变量parent去进行类加载。这里是一个循环过程，直到将加载任务委托给Bootstrap ClassLoader 结束，如果Bootstrap ClassLoader也没有找到则交给各个子类自己加载，一直到最后，如果没有任何类加载器能加载则会抛出ClassNotFoundException。 为什么要设计双亲委派机制？ 沙箱安全机制 自己写的java.lang.String.class类不会被加载,这样可以防止核心API库被随意篡改。 为了不让我们写String类，类加载采用委托机制，这样可以保证爸爸们优先，爸爸们能找到的类，儿子就没有机会加载。而String类是Bootstrap加载器加载的，就算自己重写，也总是使用Java系统提供的String，自己写的String类根本没有机会得到加载。 避免类的重复加载 当父亲已经加载了该类, 就没必要子classLoader再加载一次,保证被加载的唯一性。 引申内容（付费内容） JVM 类加载器和类本身一同确立类在Java虚拟机中的唯一性问题：由不同类加载器加载同一个类，实例化为对象。使用instanceof判断该对象与该类的归属，请问结果是true还是false？ 答案是false。 验证解析import java.io.IOException; import java.io.InputStream; public class ClassLoaderTest { public static void main(String[] args) throws Exception { ClassLoader myLoader = new ClassLoader() { @SuppressWarnings(&quot;ResultOfMethodCallIgnored&quot;) @Override public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException { try { String fileName = name.substring(name.lastIndexOf(&quot;.&quot;) + 1) + &quot;.class&quot;; InputStream is = getClass().getResourceAsStream(fileName); if (is == null) { return super.loadClass(name); } byte[] b = new byte[is.available()]; is.read(b); return defineClass(name, b, 0, b.length); } catch (IOException e) { throw new ClassNotFoundException(name); } } }; Object obj = myLoader.loadClass(&quot;Practice.Java.ClassLoaderTest&quot;).newInstance(); System.out.println(obj.getClass()); System.out.println(obj instanceof Practice.Java.ClassLoaderTest); } } 输出结果： class Practice.Java.ClassLoaderTest false 原因对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。 结果分析两行输出结果中，从第一句可以看出，这个对象确实是类Practice.Java.ClassLoaderTest实例化出来的对象，但从第二句可以发现，这个对象与类Practice.Java.ClassLoaderTest做所属类型检查的时候却返回了false。 这是因为虚拟机中存在了两个ClassLoaderTest类，一个是由系统应用程序类加载器加载的，另外一个是由我们自定义的类加载器加载的。虽然都来自同一个Class文件，但依然是两个独立的类，做对象所属类型检查时结果自然为false。 结论Java类加载器这种特性可以简单的总结为命名空间。即在 Java 虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的。即便是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。 论证参考：《深入理解JVM虚拟机：JVM高级特性与最佳实践》以及转载如下的大佬的文章内容：https://blog.csdn.net/qq_39431405/article/details/121612250https://blog.csdn.net/Notzuonotdied/article/details/112059187","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"JVM","slug":"JVM","permalink":"/tags/JVM/"},{"name":"JAVA","slug":"JAVA","permalink":"/tags/JAVA/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"【开发问题解决方案】java.lang.ArithmeticException_ _ by zero","slug":"【开发问题解决方案】java.lang.ArithmeticException_ _ by zero","date":"2022-04-20T04:58:43.000Z","updated":"2022-04-21T15:15:31.900Z","comments":false,"path":"2022/04/20/【开发问题解决方案】java.lang.ArithmeticException_ _ by zero/","link":"","permalink":"/2022/04/20/【开发问题解决方案】java.lang.ArithmeticException_ _ by zero/","excerpt":"","text":"问题背景：在做查询多条数据结果的柱状图百分比时候，由于有的查询结果值是”0”，后台报错如下java.lang.ArithmeticException: / by zero 问题分析：使用0作为除数导致了报错 简单的代码示例： public static void main(String[] args) { int a= 0; int b = 5; float d = 0; double c=0; System.out.println(b/d); System.out.println(b/c); System.out.println(b/a); } 结果如下：可以看到当”0”是int类型的值时，当做除数会报错：/by zero 业务SQL： SELECT IFNULL( (SELECT COUNT(1) FROM joint_transfer_company WHERE DATE_FORMAT(create_time, &#39;%Y-%m&#39;) = &#39;&quot; + month + &quot;&#39; AND zoneId = &#39;&quot; + zoneId + &quot;&#39;), 0 ) AS totalHouse, IFNULL( (SELECT COUNT(1) FROM joint_transfer_company WHERE DATE_FORMAT(create_time, &#39;%Y-%m&#39;) = &#39;&quot; + month + &quot;&#39; AND zoneId = &#39;&quot; + zoneId + &quot;&#39; AND `status` = &#39;1&#39;), 0 ) AS personHouse, IFNULL( (SELECT COUNT(1) FROM joint_transfer_company WHERE DATE_FORMAT(create_time, &#39;%Y-%m&#39;) = &#39;&quot; + month + &quot;&#39; AND zoneId = &#39;&quot; + zoneId + &quot;&#39; AND `status` = &#39;2&#39;), 0 ) AS companyHouse, IFNULL( (SELECT COUNT(1) FROM joint_transfer_company WHERE DATE_FORMAT(create_time, &#39;%Y-%m&#39;) = &#39;&quot; + month + &quot;&#39; AND zoneId = &#39;&quot; + zoneId + &quot;&#39; AND `status` = &#39;3&#39;), 0 ) AS personsCompany, IFNULL( (SELECT COUNT(1) FROM joint_transfer_company WHERE DATE_FORMAT(create_time, &#39;%Y-%m&#39;) = &#39;&quot; + month + &quot;&#39; AND zoneId = &#39;&quot; + zoneId + &quot;&#39; AND `status` = &#39;4&#39;), 0 ) AS companysPerson, IFNULL( (SELECT COUNT(1) FROM joint_transfer_company WHERE house_state = &#39;5&#39; AND DATE_FORMAT(create_time, &#39;%Y-%m&#39;) = &#39;&quot; + month + &quot;&#39; AND zoneId = &#39;&quot; + zoneId + &quot;&#39;), 0 ) AS totalJoints, IFNULL( (SELECT COUNT(1) FROM joint_transfer_company WHERE `water_state` = &#39;5&#39; AND DATE_FORMAT(create_time, &#39;%Y-%m&#39;) = &#39;&quot; + month + &quot;&#39; AND zoneId = &#39;&quot; + zoneId + &quot;&#39;), 0 ) AS waterCount, IFNULL( (SELECT COUNT(1) FROM joint_transfer_company WHERE electricity_state = &#39;5&#39; AND DATE_FORMAT(create_time, &#39;%Y-%m&#39;) = &#39;&quot; + month + &quot;&#39; AND zoneId = &#39;&quot; + zoneId + &quot;&#39;), 0 ) AS electricCount, IFNULL( (SELECT COUNT(1) FROM joint_transfer_company WHERE gas_state = &#39;5&#39; AND DATE_FORMAT(create_time, &#39;%Y-%m&#39;) = &#39;&quot; + month + &quot;&#39; AND zoneId = &#39;&quot; + zoneId + &quot;&#39;), 0 ) AS gasCount, IFNULL( (SELECT COUNT(1) FROM joint_transfer_company WHERE water_state = &#39;3&#39; AND DATE_FORMAT(create_time, &#39;%Y-%m&#39;) = &#39;&quot; + month + &quot;&#39; AND zoneId = &#39;&quot; + zoneId + &quot;&#39;), 0 ) AS waterRefuse, IFNULL( (SELECT COUNT(1) FROM joint_transfer_company WHERE electricity_state = &#39;3&#39; AND DATE_FORMAT(create_time, &#39;%Y-%m&#39;) = &#39;&quot; + month + &quot;&#39; AND zoneId = &#39;&quot; + zoneId + &quot;&#39;), 0 ) AS electricRefuse, IFNULL( (SELECT COUNT(1) FROM joint_transfer_company WHERE gas_state = &#39;3&#39; AND DATE_FORMAT(create_time, &#39;%Y-%m&#39;) = &#39;&quot; + month + &quot;&#39; AND zoneId = &#39;&quot; + zoneId + &quot;&#39;), 0 ) AS gasRefuse 修改加个if-else判断逻辑 if(monthAnalyse.getWaterCount().equals(&quot;0&quot;)){ monthAnalyse.setWaterRate(0 + &quot;%&quot;); }else{ String waterRate = String.valueOf(new BigDecimal(monthAnalyse.getWaterCount()).divide(new BigDecimal(monthAnalyse.getTotalHouse()), 2, BigDecimal.ROUND_HALF_UP).multiply(new BigDecimal(&quot;100&quot;))); monthAnalyse.setWaterRate(waterRate + &quot;%&quot;); } 所以就当我们在处理业务逻辑时，要进行判断，来规避这样的传参问题。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"解决方案","slug":"解决方案","permalink":"/tags/解决方案/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"【脏数据】什么是脏数据：脏数据的种类、类型","slug":"【脏数据】什么是脏数据：脏数据的种类、类型","date":"2022-04-17T15:04:57.000Z","updated":"2022-04-17T15:07:40.941Z","comments":false,"path":"2022/04/17/【脏数据】什么是脏数据：脏数据的种类、类型/","link":"","permalink":"/2022/04/17/【脏数据】什么是脏数据：脏数据的种类、类型/","excerpt":"","text":"什么是“脏”数据？通俗来说，它是因数据重复录入、共同处理等不规范操作而产生的混乱、无效数据。这些数据不能为企业带来价值，反而会占据存储空间，浪费企业的资源。因此，这些数据被称为“脏”数据，不仅没有价值，还会“污染”其他的数据。 某些“脏”数据还可能给企业带来重大损失。曾经有一家保险公司，把客户的资料存储在数据库中，并进行了如下规定：在存入新的数据之前，要对数据库进行检索，以查看其中是否存在相关记录。 然而，一些数据员偷懒，擅自跳过搜索环节，直接存入了新的数据，导致数据的重复录入。久而久之，系统运行越来越缓慢，搜索结果越来越不准确，最终数据库完全失灵，给公司造成巨大的经济损失。这个时候，保险公司才如梦初醒，决定解决这个问题。公司花费了一个星期的时间，将这些积存在数据库中的“脏”数据全部清除。 当数据出现问题的时候，苦心构建的数据库就失去了原有价值。正因如此，处理“脏”数据的工作就变得十分重要，而且越早开始越好。因此，我们有必要了解一下“脏”数据的种类。 1.缺失数据导致数据缺失的原因有很多种，例如系统问题、人为问题等。假如出现了数据缺失情况，为了不影响数据分析结果的准确性，在数据分析时就需要进行补值，或者将空值排除在分析范围之外。 排除空值会减少数据分析的样本总量，这个时候可以选择性地纳入一些平均数、比例随机数等。若系统中还留有缺失数据的相关记录，可以通过系统再次引入，若系统中也没有这些数据记录，就只能通过补录或者直接放弃这部分数据来解决。 2.重复数据相同的数据出现多次的情况相对而言更容易处理，因为只需要去除重复数据即可。但假如数据出现不完全重复的情况，例如某酒店VIP会员数据中，除了住址、姓名不一样，其余的大多数数据都是一样的，这种重复数据的处理就比较麻烦了。假如数据中有时间、日期，仍然可以以此作为判断标准来解决，但假如没有时间、日期这些数据，就只能通过人工筛选来处理。 3.错误数据错误数据一般是因为数据没有按照规定程序进行记录而出现的。例如异常值，某个产品价格为1到100元，而统计中偏偏出现200这个值；例如格式错误，将文字录成了日期格式；例如数据不统一，关于天津的记录有天津、tianjin。 对于异常值，可以通过限定区间的方法进行排除；对于格式错误，需要通过系统内部逻辑结构进行查找；对于数据不统一，无法从系统方面去解决，因为它并不属于真正的“错误”，系统并不能判断出天津和tianjin属于同一“事物”，因此只能通过人工干预的方法，做出匹配规则，用规则表去关联原始表。例如，一旦出现tianjin这个数据就直接匹配到天津。 4.不可用数据有些数据虽然正确但却无法使用。例如地址为“上海浦东新区”，想要对“区”级别的数据进行分析时，还需要将“浦东”拆出来。这种情况的解决方案只能用关键词匹配的方法，而且不一定能够得到完美解决。 转载原文","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"Mysql","slug":"Mysql","permalink":"/tags/Mysql/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"【Redis】持久化机制RDB、AOF","slug":"【Redis】持久化机制RDB、AOF","date":"2022-04-15T15:49:32.000Z","updated":"2022-04-17T15:04:39.161Z","comments":false,"path":"2022/04/15/【Redis】持久化机制RDB、AOF/","link":"","permalink":"/2022/04/15/【Redis】持久化机制RDB、AOF/","excerpt":"","text":"RDB: RDB是将支持当前数据的快照存成一个数据文件的持久化机制。 在生成快照时，将当前进程fork出一个子进程 然后再子进程中循环所有的数据，将数据写入到二进制文件中。 当子进程将快照写入临时文件完毕后，用临时文件替换原来的快照文件，然后子进程退出。 fork：是UNIX关于进程管理的一个术语，本质是新开一个进程，但是不从磁盘加载代码，而是从内存现有进程复制一份。 优点: 一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这样非常方便进行备份。比如你可能打算每1天归档一些数据。 方便备份的同时，我们也很容易的将一个RDB文件移动到其他存储物质上。 RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。 缺点:如果你想在服务器上避免数据的丢失，那么RDB就不适合了，因为RDB文件需要保存整个数据集的状态，因为你可能会在5分钟才保存一次RDB文件，在这种情况下，一旦发生故障停机，你可能会损失好几分钟的数据。每次在保存RDB的时候，Redis都要fork出一个子进程，并由子进程来进行实际的持久化工作，如果在数据集比较庞大时，fork可能会非常耗时，造成服务器在那么一瞬间会停止处理客户端；虽然AOF重写也需要进行fork，但AOF重写的执行时间间隔有多长，数据的耐久性都不会有任何损失。 AOF:AOF: Redis 默认不开启。它的出现是为了弥补RDB的不足（数据的不一致性），所以它采用日志的形式来记录每个写操作，并追加到文件中。Redis 重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。AOF的工作原理就是是将写操作追加到文件中，文件的冗余内容会越来越多。所以Redis 新增了重写机制。当AOF文件的大小超过所设定的最大值时，Redis就会对AOF文件的内容压缩。 优点:数据的完整性和一致性更高 缺点:因为AOF记录的内容多，文件会越来越大，数据恢复也会越来越慢。 总结 Redis 默认开启RDB持久化方式，在指定的时间间隔内，执行指定次数的写操作，则将内存中的数据写入到磁盘中。 RDB 持久化适合大规模的数据恢复但它的数据一致性和完整性较差。 Redis 需要手动开启AOF持久化方式，默认是每秒将写操作日志追加到AOF文件中。 AOF 的数据完整性比RDB高，但记录内容多了，会影响数据恢复的效率。 Redis 针对 AOF文件大的问题，提供重写的瘦身机制。 若只打算用Redis 做缓存，可以关闭持久化。 若打算使用Redis 的持久化。建议RDB和AOF都开启。其实RDB更适合做数据的备份，留一后手。AOF出问题了，还有RDB。 转载，原文点此","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"【正则表达式】详解及常用的使用方法详解","slug":"【正则表达式】详解及常用的使用方法详解","date":"2022-04-10T01:53:09.000Z","updated":"2022-04-11T14:32:03.046Z","comments":false,"path":"2022/04/10/【正则表达式】详解及常用的使用方法详解/","link":"","permalink":"/2022/04/10/【正则表达式】详解及常用的使用方法详解/","excerpt":"","text":"一、什么是正则表达式？1.定义： 正则表达式(regular expression)描述了一种字符串匹配的模式，可以用来检查一个串是否含有某种子串、将匹配的子串做替换或者从某个串中取出符合某个条件的子串等。构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。 2.组成：正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为”元字符”）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。 3.何时使用： 验证——从头到尾完整匹配！ 查找——只要部分匹配即可！ 二、正则表达式的基本语法和规则 1.备选字符集：规定某一位字符可用的备选字符的集合 语法：[可选字符列表] 强调： 无论备选字符集包含多少字符，只能选1个 必须选1个！比如：6位数字的密码[0123456789][0123456789][0123456789][0123456789][0123456789][0123456789] 简化：1. 当备选字符连续时，可用-表示范围的区间 比如：[0123456789]–&gt;[0-9] [0-9][0-9][0-9][0-9][0-9][0-9] [a-z]--&gt;1位小写字母 [A-Z]--&gt;1位大写字母 [A-Za-z]--&gt;1位字母，大小写都行 [0-9a-zA-Z]--&gt;1位字母或数字都行 反选：[^不能选的字符列表] 比如：[^47] 强调：^作“除了”使用时，只能放在开头 预定义字符集：为常用的字符集专门提供的简化写法！ “\\d”–&gt;[0-9]–&gt;1位数字 “\\w”–&gt;[0-9a-zA-Z_]–&gt;1位字母,数字或_ “\\s”–&gt;1位空字符：匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 “ . “: 除换行回车外的任何一个字符,如： “a.[0-9]”：表示一个字符串有一个”a”后面跟着一个任意字符和一个数字；“^.{3}$”：表示有任意三个字符的字符串（长度为3个字符） \\t——–匹配一个制表符 预定义字符的反义：预定义字符的大写形式都是小写的反义 \\D—-&gt;1位非数字字符 \\S——匹配任何非空白字符。等价于 [^\\f\\n\\r\\t\\v]。 \\v——匹配一个垂直制表符 \\n——匹配一个换行符 \\r——-匹配一个回车符 数量词：规定相邻的字符集可出现的次数确定数量：3种： {n}–&gt; 必须反复出现n位 {n,m}–&gt; 最少出现n次，最多出现m次{n,}–&gt;至少出现n次，多了不限！ 比如：/^\\d{6}$/——6位数字 手机号规则： 第1位：只能是1 第2位：[34578] 第3位之后，必须是9位数字 手机号：/^1[34578]\\d{9}$/ 不确定数量：3种： *: 有没有都行，次数不限，相当于{0,} +: 至少1次，重复次数不限，相当于{1,} ?: 有没有都行，最多1次,相当于{0,1} ():分组 |: 左右两正则表达式选其一 身份证号逻辑： 前15位数字 16,17位必须是数字 最后一位可以是数字或X x 后三位 可有可无，如果有，只能出现一次 \\d{15}(\\d\\d[0-9Xx])? 手机号： 手机号前可能出现+86或0086。 前缀可有可无，且只能出现一次 前缀和手机号之间可以有或没有任意个空字符 第1位：只能是1 第2位：[34578] 第3位之后，必须是9位数字 手机号： (\\+86|0086)?\\s*1[34578]\\d{9} 指定匹配位置：^表达式: 必须以表达式的规则为开头 表达式$: 必须以表达式的规则为结尾 比如：选择字符串开头的空格？^\\s* 选择结尾空格?\\s*$ 选择开头或结尾的空格？^\\s*|\\s*$ *预告：今后只要在程序中执行验证：都要前加^后加$* 表示从头到尾完整匹配。 比如：test()： ^\\d{6}$——从头到尾必须只能是6位数字 1234567 预判：在正式匹配正则表达式之前，先预读整个字符串，进行初步匹配，如果预判都未通过，则不再验证！ 1）(?=表达式): 先浏览字符串是否满足表达式的要求 何时使用：只要正则中出现类似”而且” 比如：4位数字，但不能包含4和7 (?=[^47]$) 是否由除了4,7之外的字符组成 2）(?!表达式):先检查字符串是否不满足表达式要求 比如：6位以上密码。 字母,数字组成 首字母不能是数字: [a-zA-Z][a-zA-Z0-9]{5,} 必须至少包含1个大写字母 不能都由小写字母和数字组成: (?![a-z0-9]+$) 必须至少包含1个数字 不能都由小写字母和大写字母组成: (?![a-zA-Z]+$) 6.特殊字符 所谓特殊字符，就是一些有特殊含义的字符，如”.txt”中的，简单的说就是表示任何字符串的意思。如果要查找文件名中有的文件，则需要对进行转义，即在其前加一个\\。ls *.txt。许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符 () 放在它们前面。下面列出了正则表达式中的特殊字符：（请注意在方括号中，不需要转义字符。） “$”——匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。要匹配 $ 字符本身，请使用 \\$。 “()”—-标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 和和。 “”—-匹配前面的子表达式零次或多次。要匹配 字符，请使用 *。 “+”—–匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。 “.”—-匹配除换行符 \\n之外的任何单字符。要匹配 .，请使用 .。 “[”——标记一个中括号表达式的开始。要匹配 [，请使用 [。 “?”—-匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \\?。 “\\”—-将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\\n’ 匹配换行符。序列 ‘\\‘ 匹配 “\\”，而 ‘(‘ 则匹配 “(“. “^”—–匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \\^。 “{”—-标记限定符表达式的开始。要匹配 {，请使用 {。 “|”—-指明两项之间的一个选择。要匹配 |，请使用 |。 贪婪模式和懒惰模式：贪婪模式：默认情况下，正则表达式会匹配最大的符合条件的字符串, *、+和?限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。 贪婪模式原因：(.*) (.+) 懒惰模式：正则表达式仅匹配最小的符合规则的字符串 比如：筛选网页中的a元素： &lt;a\\s+(.)href\\s=\\s[“‘]([^’”])[“‘] 贪婪模式–&gt;懒惰模式：.*? 例如: 您可能搜索 HTML 文档，以查找括在 H1 标记内的章节标题。该文本在您的文档中如下： Chapter 1 - Introduction to Regular Expression 下面的表达式匹配从开始小于符号 (&lt;) 到关闭 H1 标记的大于符号 (&gt;) 之间的所有内容。 /&lt;.*&gt;/ 如果您只需要匹配开始 H1 标记，下面的”非贪心”表达式只匹配 。 /&lt;.*?&gt;/ 通过在 *、+ 或 ? 限定符之后放置 ?，该表达式从”贪心”表达式转换为”非贪心”表达式或者最小匹配。 三、常用正则表达式示例及说明：1.正则表达式验证控制文本框的输入字符类型 1）只能输入数字和英文的： 2）只能输入数字的： 3）只能输入全角的： 4）只能输入汉字的： 2.正则表达式的应用实例通俗说明 //校验是否全由数字组成 /^[0-9]{1,20}$/ ^ 表示打头的字符要匹配紧跟^后面的规则 $ 表示打头的字符要匹配紧靠$前面的规则 [ ] 中的内容是可选字符集 [0-9] 表示要求字符范围在0-9之间 {1,20}表示数字字符串长度合法为1到20，即为[0-9]中的字符出现次数的范围是1到20次。/^ 和 $/成对使用应该是表示要求整个字符串完全匹配定义的规则，而不是只匹配字符串中的一个子串。 //校验登录名：只能输入5-20个以字母开头、可带数字、“_”、“.”的字串 /^[a-zA-Z]{1}([a-zA-Z0-9]|[._]){4,19}$/ ^[a-zA-Z]{1} 表示第一个字符要求是字母。 ([a-zA-Z0-9]|[.]){4,19} 表示从第二位开始（因为它紧跟在上个表达式后面）的一个长度为4到9位的字符串，它要求是由大小写字母、数字或者特殊字符集[.]组成。 //校验用户姓名：只能输入1-30个以字母开头的字串 /^[a-zA-Z]{1,30}$/ //校验密码：只能输入6-20个字母、数字、下划线 /^(\\w){6,20}$/ \\w：用于匹配字母，数字或下划线字符 //校验普通电话、传真号码：可以“+”或数字开头，可含有“-” 和 “ ” /^[+]{0,1}(\\d){1,3}[ ]?([-]?((\\d)|[ ]){1,12})+$/ \\d：用于匹配从0到9的数字； “?”元字符规定其前导对象必须在目标对象中连续出现零次或一次 可以匹配的字符串如：+123 -999 999 ； +123-999 999 ；123 999 999 ；+123 999999等 //校验URL /^http[s]{0,1}:\\/\\/.+$/ 或 /^http[s]{0,1}:\\/\\/.{1,n}$/ (表示url串的长度为length(“https://”) + n ) \\ / ：表示字符“/”。 . 表示所有字符的集 等同于{1,}，就是1到正无穷吧。 转载","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"【注解】 @CrossOrigin","slug":"【注解】 @CrossOrigin","date":"2022-04-09T07:17:02.000Z","updated":"2022-04-11T14:32:03.071Z","comments":false,"path":"2022/04/09/【注解】 @CrossOrigin/","link":"","permalink":"/2022/04/09/【注解】 @CrossOrigin/","excerpt":"","text":"在Controller中看到@CrossOrigin ，这是什么？有什么用？为什么要用？ @CrossOrigin是用来处理跨域请求的注解跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript施加的安全限制。 出于安全原因，浏览器禁止Ajax调用驻留在当前原点之外的资源。例如，当你在一个标签中检查你的银行账户时，你可以在另一个选项卡上拥有EVILL网站。来自EVILL的脚本不能够对你的银行API做出Ajax请求（从你的帐户中取出钱！）使用您的凭据。 跨源资源共享（CORS）是由大多数浏览器实现的W3C规范，允许您灵活地指定什么样的跨域请求被授权，而不是使用一些不太安全和不太强大的策略，如IFRAME或JSONP。 一、跨域(CORS)支持： Spring Framework 4.2 GA为CORS提供了第一类支持，使您比通常的基于过滤器的解决方案更容易和更强大地配置它。所以springMVC的版本要在4.2或以上版本才支持@CrossOrigin 1、controller配置CORS1.1、controller方法的CORS配置，您可以向@RequestMapping注解处理程序方法添加一个@CrossOrigin注解，以便启用CORS（默认情况下，@CrossOrigin允许在@RequestMapping注解中指定的所有源和HTTP方法）： @RestController @RequestMapping(&quot;/account&quot;) public class AccountController { @CrossOrigin @GetMapping(&quot;/{id}&quot;) public Account retrieve(@PathVariable Long id) { // ... } @DeleteMapping(&quot;/{id}&quot;) public void remove(@PathVariable Long id) { // ... } } 其中@CrossOrigin中的2个参数： origins ： 允许可访问的域列表 maxAge：准备响应前的缓存持续的最大时间（以秒为单位）。 1.2、为整个controller启用@CrossOrigin @CrossOrigin(origins = &quot;http://domain2.com&quot;, maxAge = 3600) @RestController @RequestMapping(&quot;/account&quot;) public class AccountController { @GetMapping(&quot;/{id}&quot;) public Account retrieve(@PathVariable Long id) { // ... } @DeleteMapping(&quot;/{id}&quot;) public void remove(@PathVariable Long id) { // ... } } 在这个例子中，对于retrieve()和remove()处理方法都启用了跨域支持，还可以看到如何使用@CrossOrigin属性定制CORS配置。 1.3、同时使用controller和方法级别的CORS配置，Spring将合并两个注释属性以创建合并的CORS配置。 @CrossOrigin(maxAge = 3600) @RestController @RequestMapping(&quot;/account&quot;) public class AccountController { @CrossOrigin(origins = &quot;http://domain2.com&quot;) @GetMapping(&quot;/{id}&quot;) public Account retrieve(@PathVariable Long id) { // ... } @DeleteMapping(&quot;/{id}&quot;) public void remove(@PathVariable Long id) { // ... } } 1.4、如果您正在使用Spring Security，请确保在Spring安全级别启用CORS，并允许它利用Spring MVC级别定义的配置。 @EnableWebSecurity public class WebSecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.cors().and()... } } 2、全局CORS配置 除了细粒度、基于注释的配置之外，您还可能需要定义一些全局CORS配置。这类似于使用筛选器，但可以声明为Spring MVC并结合细粒度@CrossOrigin配置。默认情况下，所有origins and GET, HEAD and POST methods是允许的。 JavaConfig 使整个应用程序的CORS简化为： @Configuration @EnableWebMvc public class WebConfig extends WebMvcConfigurerAdapter { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(&quot;/**&quot;); } } 如果您正在使用Spring Boot，建议将WebMvcConfigurer bean声明如下： @Configuration public class MyConfiguration { @Bean public WebMvcConfigurer corsConfigurer() { return new WebMvcConfigurerAdapter() { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(&quot;/**&quot;); } }; } } 您可以轻松地更改任何属性，以及仅将此CORS配置应用到特定的路径模式： @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(&quot;/api/**&quot;) .allowedOrigins(&quot;http://domain2.com&quot;) .allowedMethods(&quot;PUT&quot;, &quot;DELETE&quot;) .allowedHeaders(&quot;header1&quot;, &quot;header2&quot;, &quot;header3&quot;) .exposedHeaders(&quot;header1&quot;, &quot;header2&quot;) .allowCredentials(false).maxAge(3600); } 如果您正在使用Spring Security，请确保在Spring安全级别启用CORS，并允许它利用Spring MVC级别定义的配置。 3、XML命名空间还可以将CORS与MVC XML命名空间配置。 a、如果整个项目所有方法都可以访问，则可以这样配置；此最小XML配置使CORS在/**路径模式具有与JavaConfig相同的缺省属性： &lt;mvc:cors&gt; &lt;mvc:mapping path=&quot;/**&quot; /&gt; &lt;/mvc:cors&gt; 其中* 表示匹配到下一层；** 表示后面不管有多少层，都能匹配。 如： &lt;mvc:cors&gt; &lt;mvc:mapping path=&quot;/api/*&quot;/&gt; &lt;/mvc:cors&gt; 这个可以匹配到的路径有： /api/aaa /api/bbbb 不能匹配的： /api/aaa/bbb 因为* 只能匹配到下一层路径，如果想后面不管多少层都可以匹配，配置如下： &lt;mvc:cors&gt; &lt;mvc:mapping path=&quot;/api/**&quot;/&gt; &lt;/mvc:cors&gt; 注：其实就是一个(*)变成两个(**) b、也可以用定制属性声明几个CORS映射： &lt;mvc:cors&gt; &lt;mvc:mapping path=&quot;/api/**&quot; allowed-origins=&quot;http://domain1.com, http://domain2.com&quot; allowed-methods=&quot;GET, PUT&quot; allowed-headers=&quot;header1, header2, header3&quot; exposed-headers=&quot;header1, header2&quot; allow-credentials=&quot;false&quot; max-age=&quot;123&quot; /&gt; &lt;mvc:mapping path=&quot;/resources/**&quot; allowed-origins=&quot;http://domain1.com&quot; /&gt; &lt;/mvc:cors&gt; 请求路径有/api/，方法示例如下： @RequestMapping(&quot;/api/crossDomain&quot;) @ResponseBody public String crossDomain(HttpServletRequest req, HttpServletResponse res, String name){ …… …… } c、如果使用Spring Security，不要忘记在Spring安全级别启用CORS： &lt;http&gt; &lt;!-- Default to Spring MVC&#39;s CORS configuration --&gt; &lt;cors /&gt; ... &lt;/http&gt; 4、How does it work? CORS请求（包括预选的带有选项方法）被自动发送到注册的各种HandlerMapping 。它们处理CORS准备请求并拦截CORS简单和实际请求，这得益于CorsProcessor实现（默认情况下默认DefaultCorsProcessor处理器），以便添加相关的CORS响应头（如Access-Control-Allow-Origin）。 CorsConfiguration 允许您指定CORS请求应该如何处理：允许origins, headers, methods等。 a、AbstractHandlerMapping#setCorsConfiguration() 允许指定一个映射，其中有几个CorsConfiguration 映射在路径模式上，比如/api/**。 b、子类可以通过重写AbstractHandlerMapping类的getCorsConfiguration(Object, HttpServletRequest)方法来提供自己的CorsConfiguration。 c、处理程序可以实现 CorsConfigurationSource接口（如ResourceHttpRequestHandler），以便为每个请求提供一个CorsConfiguration。 5、基于过滤器的CORS支持 作为上述其他方法的替代，Spring框架还提供了CorsFilter。在这种情况下，不用使用@CrossOrigin或WebMvcConfigurer#addCorsMappings(CorsRegistry),，例如，可以在Spring Boot应用程序中声明如下的过滤器： @Configuration public class MyConfiguration { @Bean public FilterRegistrationBean corsFilter() { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); CorsConfiguration config = new CorsConfiguration(); config.setAllowCredentials(true); config.addAllowedOrigin(&quot;http://domain1.com&quot;); config.addAllowedHeader(&quot;*&quot;); config.addAllowedMethod(&quot;*&quot;); source.registerCorsConfiguration(&quot;/**&quot;, config); FilterRegistrationBean bean = new FilterRegistrationBean(new CorsFilter(source)); bean.setOrder(0); return bean; } } 三、spring注解@CrossOrigin不起作用的原因1、是springMVC的版本要在4.2或以上版本才支持@CrossOrigin 2、非@CrossOrigin没有解决跨域请求问题，而是不正确的请求导致无法得到预期的响应，导致浏览器端提示跨域问题。 3、在Controller注解上方添加@CrossOrigin注解后，仍然出现跨域问题，解决方案之一就是： 在@RequestMapping注解中没有指定Get、Post方式，具体指定后，问题解决。 类似代码如下： @CrossOrigin @RestController public class person{ @RequestMapping(method = RequestMethod.GET) public String add() { // 若干代码 } } 转载作者：淼淼之森欢迎任何形式的转载，但请务必注明出处。如果你觉得本文还可以，那就点击一下推荐，让更多人看到吧！限于本人水平，如果文章和代码有表述不当之处，还请不吝赐教。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"web","slug":"web","permalink":"/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"什么是接口测试和性能测试？","slug":"什么是接口测试和性能测试？","date":"2022-04-08T01:56:12.000Z","updated":"2022-04-11T14:08:52.978Z","comments":false,"path":"2022/04/08/什么是接口测试和性能测试？/","link":"","permalink":"/2022/04/08/什么是接口测试和性能测试？/","excerpt":"","text":"在按照接口文档完成对应的接口实现后，我们会使用Postman做接口测试，那么什么是接口测试呢？性能测试、功能测试又是什么呢？ 一、什么是接口测试接口测试是测试系统组件间接口的一种测试。接口测试主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。测试的重点是要检查数据的交换，传递和控制管理过程，以及系统间的相互逻辑依赖关系等。 二、接口测试原理通过测试程序模拟客户端向服务器发送请求报文，服务器接收请求报文后对相应的报文做出处理然后再把应答报文发送给客户端，客户端接收应答报文这一过程（request（请求）→response（响应）） 三、什么是性能测试1.软件性能测试指通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行的测试活动。 2.软件性能测试指通过模拟生产运行的业务压力或用户使用场景来测试系统的性能指标是否满足性能需求要求的测试活动。 3.软件性能测试指检验软件性能是否符合性能指标需求定义的测试活动。 四、接口测试和性能测试的区别接口测试和性能测试主要区别是侧重点不一样，接口测试是针对后端开发的接口（不一定是http的，也有可能是tcp的），而性能测试是偏重于产品的各方面各阶段性能（接口的性能，页面的性能，app的性能），可以说性能测试的覆盖度比接口更大一些。 以web端测试为例子。 简单来说，它俩区别就在于性能测试有多用户（并发）的概念，而接口测试只是单用户场景。我们做接口测试是是用于验证接口的请求和返回是否匹配（其实可以理解成接口测试也是一种功能测试）； 而性能测试则是很多人同时在做这种接口测试，更侧重于真实的用户场景。因为我们研发完的产品投入市场后，不会就专门给某一个人使用功能，肯定是会有很多人同时在用我们的产品功能。那在这里，很多人同时在用其实就是性能的一个关键点。 所以性能测试和接口测试的区别为：性能测试近乎等同于很多用户同时在做接口测试。 apipost","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"JAVA","slug":"JAVA","permalink":"/tags/JAVA/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"【转载】JIT","slug":"【转载】JIT","date":"2022-04-05T08:22:19.000Z","updated":"2022-04-11T14:12:56.241Z","comments":false,"path":"2022/04/05/【转载】JIT/","link":"","permalink":"/2022/04/05/【转载】JIT/","excerpt":"","text":"工作原理 当JIT编译启用时(默认是启用的)，JVM读入.class文件解释后，将其发给JIT编译器。JIT编译器将字节码编译成本机机器代码。 通常javac将程序源代码编译，转换成java字节码，JVM通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢。为了提高执行速度，引入了JIT技术。 在运行时JIT会把翻译过的机器码保存起来，已备下次使用，因此从理论上来说，采用该JIT技术可以，可以接近以前纯编译技术。————————————————2.相关知识 JIT是just in time,即时编译技术。使用该技术，能够加速java程序的执行速度。 JIT并不总是奏效，不能期望JIT一定能够加速你代码执行的速度，更糟糕的是她有可能降低代码的执行速度。这取决于你的代码结构，当然很多情况下我们还是能够如愿以偿的。 从上面我们知道了之所以要关闭JITjava.lang.Compiler.disable(); 是因为加快执行的速度。由于JIT对每条字节码都进行编译，造成了编译过程负担过重。为了避免这种情况，当前的JIT只对经常执行的字节码进行编译，如循环等.————————————————JIT编译器1.避免函数被直接解释执行，先将整个函数体编译成机器指令，再执行相应的机器指令，提高执行效率。 2.Java语言的编译过程时一段不确定的操作过程，可以是以下任意一种： （1）前端编译器：把.java文件转化为.class（字节码文件）的过程 （2）后端编译器（jit编译)：把字节码转为机器码的过程 （3）静态提前编译器（AOP）：直接把*.java文件编译为本地机器码的过程 3.采用热点代码及探测方式 根据代码被调用执行的频率，在执行期间根据哪些经常被调用的热点代码做深度优化，将其直接编译为机器码，提高执行效率。 4.热点代码 （1）一个被多次调用的方法 （2）一个方法体内部循环多次的循环体 5.不同虚拟机采用的热点探测方式不同，其中hotspot vm 采用基于计数器的热点探测方式，为每个方法建立两个不同类型的计数器，即调用计数器和回边计数器，分别用于统计方法的调用次数和循环体的执行次数。 6.在Client模式下，阈值为1500，server下阈值为10000，超过便会触发jit编译，可通过虚拟机参数-xx:compileThreshold设置————————————————版权声明：本文为CSDN博主「weixin_44836361」的原创文章，原文链接：https://blog.csdn.net/weixin_44836361/article/details/119170109 http://www.360doc.com/content/19/0613/18/835902_842247843.shtml","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"JAVA","slug":"JAVA","permalink":"/tags/JAVA/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]},{"title":"【微服务注解】@EnableEurekaServer","slug":"【微服务注解】@EnableEurekaServer","date":"2022-04-04T05:29:34.000Z","updated":"2022-04-11T14:32:03.080Z","comments":false,"path":"2022/04/04/【微服务注解】@EnableEurekaServer/","link":"","permalink":"/2022/04/04/【微服务注解】@EnableEurekaServer/","excerpt":"","text":"当在启动类上添加了启动 Eureka 服务注册中心注解时，他的应用原理怎样的？激活Eureka Server相关配置的注解 EurekaServerAutoConfiguration 可以将@EnableEurekaServer 这个注解看作是⼀个开关，开启时，会激活相关配置，会作为注册中⼼。同时，他⼜引⼊了EurekaServerMarkerConfiguration类。 点进去EurekaServerMarkerConfiguration发现作者意图是：负责添加一个marker bean来激活EurekaServerAutoConfiguration 再点开EurekaServerAutoConfiguration 参考文章1参考文章2","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"web","slug":"web","permalink":"/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"【Maven】安装与在idea上的配置和使用","slug":"【Maven】安装与在idea上的配置和使用","date":"2022-04-02T02:13:21.000Z","updated":"2022-04-11T14:32:03.061Z","comments":false,"path":"2022/04/02/【Maven】安装与在idea上的配置和使用/","link":"","permalink":"/2022/04/02/【Maven】安装与在idea上的配置和使用/","excerpt":"","text":"Maven安装与配置当进入到一个新的工作地点，第一件事情就是配置环境变量。先来快速配置一下maven吧。 一、官网下载注意： Binary是可执行版本，已经编译好可以直接使用。 Source是源代码版本，需要自己编译成可执行软件才可使用。 tar.gz和zip两种压缩格式,其实这两个压缩文件里面包含的内容是同样的,只是压缩格式不同 tar.gz格式的文件比zip文件小很多,用于unix操作系统。zip格式用于Windows操作系统,但在Windows系统使用WinRar工具一样能够解压缩tar.gz格式 下载完成后，解压到某一路径下。本文以D:\\soft46\\maven3.8.5\\apache-maven-3.8.5为例，实际配置环境变量时以自己安装的路径为准。 二、配置环境变量右键此电脑–&gt;属性–&gt;高级系统设置–&gt;环境变量或者直接就在搜索窗搜索 新建变量MAVEN_HOME = D:\\soft46\\maven3.8.5\\apache-maven-3.8.5（以自己的安装路径为准） 编辑变量Path，添加变量值%MAVEN_HOME%\\bin或者D:\\soft46\\maven3.8.5\\apache-maven-3.8.5\\bin 然后win+R运行cmd，输入mvn -version，如图所示则配置成功 三、配置本地仓库在D:\\soft46\\maven3.8.5路径下新建maven-repository文件夹，用作maven的本地库。 在路径D:\\soft46\\maven3.8.5\\apache-maven-3.8.5\\conf下找到settings.xml文件 找到节点localRepository，在注释外添加（大概五十多行） D:\\soft46\\maven3.8.5\\maven-repository localRepository节点用于配置本地仓库，本地仓库其实起到了一个缓存的作用，它的默认地址是 C:\\Users\\用户名.m2。当我们从maven中获取jar包的时候，maven首先会在本地仓库中查找，如果本地仓库有则返回；如果没有则从远程仓库中获取包，并在本地库中保存。此外，我们在maven项目中运行mvn install，项目将会自动打包并安装到本地仓库中。 四、配置镜像 在settings.xml配置文件中找到mirrors节点 添加如下配置（注意要添加在和两个标签之间，其它配置同理） &lt;!-- 阿里云仓库 --&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt; &lt;/mirror&gt; 五、配置JDK 在settings.xml配置文件中找到profiles节点 添加如下配置 &lt;!-- java版本 --&gt; &lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; 配置完成，win+R运行cmd，输入mvn help:system测试，配置成功则本地仓库（E:\\Tools\\Maven\\maven-repository）中会出现一些文件 首次执行 mvn help:system 命令，Maven相关工具自动帮我们到Maven中央仓库下载缺省的或者Maven中央仓库更新的各种配置文件和类库（jar包)到Maven本地仓库中。下载完各种文件后， mvn help:system 命令会打印出所有的Java系统属性和环境变量，这些信息对我们日常的编程工作很有帮助。 六、IDEA集成Maven插件 推荐配置：设置maven在不联网的情况下使用本地插件 一般使用maven为我们提供好的骨架时，是需要联网的，配置这个，可以在没有网路的情况下，我们可以正常创建工程，并从之前已经使用过的工程中找到相应的骨架。 输入内容：-DarchetypeCatalog=internal 接下来的基本使用就没有问题了。 七、IDEA使用Maven命令前提条件：maven配置环境变量。 在保证环境变量配置没问题的情况下执行过程出现mvn不是内部命令类似的错误，建议重启编译器或者命令窗口。 IntelliJ IDEA自身已经集成了maven，不需要再去下载！ //常用maven命令 mvn -v //查看版本 mvn archetype:create //创建 Maven 项目 mvn compile //编译源代码 mvn test-compile //编译测试代码 mvn test //运行应用程序中的单元测试 mvn site //生成项目相关信息的网站 mvn package //依据项目生成 jar 文件 mvn install //在本地 Repository 中安装 jar mvn -Dmaven.test.skip=true //忽略测试文档编译 mvn clean //清除目标目录中的生成结果 mvn clean compile //将.java类编译为.class文件 mvn clean package //进行打包 mvn clean test //执行单元测试 mvn clean deploy //部署到版本仓库 mvn clean install //使其他项目使用这个jar,会安装到maven本地仓库中 mvn archetype:generate //创建项目架构 mvn dependency:list //查看已解析依赖 mvn dependency:tree //看到依赖树 mvn dependency:analyze //查看依赖的工具 mvn help:system //从中央仓库下载文件至本地仓库 mvn help:active-profiles //查看当前激活的profiles mvn help:all-profiles //查看所有profiles mvn help:effective -pom //查看完整的pom信息 可以直接在idea上面打开控制台，输入命令","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"IDEA","slug":"IDEA","permalink":"/tags/IDEA/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"jsdelivr是什么以及利用GitHub+jsdelivr搭建一个高速图床","slug":"jsdelivr是什么以及利用GitHub+jsdelivr搭建一个高速图床","date":"2022-03-30T07:34:06.000Z","updated":"2022-04-17T15:05:44.033Z","comments":false,"path":"2022/03/30/jsdelivr是什么以及利用GitHub+jsdelivr搭建一个高速图床/","link":"","permalink":"/2022/03/30/jsdelivr是什么以及利用GitHub+jsdelivr搭建一个高速图床/","excerpt":"","text":"文章背景：利用GitHub+jsdelivr搭建一个高速图床cdn好处1、集群抗攻击 广泛分布的CDN节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种D.D.o.S攻击对网站的影响，同时保证较好的服务质量 。2、带宽优化 自动生成服务器的远程Mirror(镜像)cache服务器，远程用户访问时从cache服务器上读取数据，减少远程访问的带宽、分担网络流量、减轻原站点WEB服务器负载等功能。3、远程加速 远程访问用户根据DNS负载均衡技术智能自动选择Cache服务器，选择最快的Cache服务器，加快远程访问的速度4、镜像服务 消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量。5、本地Cache加速 提高了企业站点(尤其含有大量图片和静态页面站点)的访问速度，并大大提高以上性质站点的稳定性。 一、jsdelivr是什么jsDelivr由ProspectOne维护的公共库，使用的融合CDN技术，由Cloudflare、Fastly、StackPath、QUANTIL等CDN供应商提供了全球超过750个CDN节点。最重要的是，jsDelivr在中国大陆也拥有超过数百个节点，因为jsDelivr拥有正规的ICP备案，解决了中国大陆的访问速度优化，实现真正的全球极速低延迟体验。jsDelivr是免费的、不限制带宽的，可以加速NPM、Github、wordpress内的文件。 大部分情况下外国的网站国内是不能使用的，为什么国内可以使用jsdelivr呢？要回答这个问题，必须得思考几个概念：域名，cdn，ICP。 1.1 cdn是什么？1.1.1 概念CDN全称叫做“Content Delivery Network”，中文叫内容分发网络。实际上CDN这个概念是在1996年由美国麻省理工学院的一个研究小组为改善互联网的服务质量而提出的。那么它到底是怎么改善互联网服务质量的呢？ 1.1.2 工作原理当我们使用域名访问某一个网站时，实际上就是将请求包（以Http请求为例）通过网络传输给某台服务器，比如访问“www.baidu.com”时： 首先解析出该域名所对应的IP地址(DNS域名解析) 然后将Http请求包通过网络路由到IP地址所对应的服务器 我们通常说“服务器的IP地址”，这其实不太准确，IP地址是和网卡绑定的，一个服务器可以有多个网卡，也就是可能有多个IP地址。 域名解析解析域名分为两种： 将一个域名解析为一个IP地址 将一个域名解析为另外一个域名 其实解析思路不难，我们在域名服务商购买了一个域名之后，需要去映射一个IP地址，可以用Map来表示这个关系：{域名：IP}。同时我们也可以给某个域名取一个别名，比如“www.baidu.com”取一个别名“test.baidu.com”，这种关系也可以用Map来表示：**{域名：别名}**。 这里的别名专业一点叫做CNAME，相信大家对这个词有点眼熟，它就是这个意思。而域名解析，实际上就是解析出指定域名所对应的IP地址，或者该域名的一个CNAME。 而域名解析是由DNS系统来负责的，DNS服务接受外部请求，从请求里提取域名， 如果这个域名对应的是IP地址，则返回这个IP地址 如果这个域名对应的是CNAME，则继续查找CNAME域名的IP地址，然后将该地址返回给请求发送者 请求发送者拿到IP地址之后，完成真正的请求调用。 实际上DNS系统是非常庞大的，这里不去多将，大家把它当作一个黑盒子，这个盒子的作用就是上文所描述的，这里用一个简单的图来表示一下。 没有CNAME的情况： 有CNAME的情况：特别注意：在有CNAME的情况下，我们可以发现，CNAME实际上在域名解析的过程中承担了中间人（或者说代理）的角色，这是CDN实现的关键。 CDN原理说白了就是：提高访问速度 假设百度网站现在只有一台服务器，现在有一个人在上海访问百度，如果该服务器也在上海，那么通常来说访问比较快，如果该服务器在拉萨，那么相对而言访问就比较慢了。那么这个问题的根本原因是网络传输是依赖于网线的，网线越长，那么时间肯定就越久。 那么怎么解决这个问题呢？其实思路很简单，百度在全国各地都部署一模一样的服务器就行了，专业一点叫冗余。思路很简单，但实现还是比较麻烦的，服务器上的资源分为两种：静态资源与动态资源。 静态资源：这种资源通常是很少变动的，比如图片，视频，css，javascript等等 动态资源：这种资源不同用户不同时刻访问通常是不一样的，比如ftl，jsp等等。 那么如果百度要在全国各地都部署服务器，如果说每个服务器上都有相同的动态资源，那么可能还需要配置相应的数据库，因为动态资源所记录的信息通常会存储在数据库中，那么这就涉及到了数据同步等等问题，这会导致成本很高，这种做法专业一点其实就是集群。 那么有没有成本比较低的方式呢，有，就是在每个服务器上只部署静态资源，静态资源通常不涉及到数据库，所以成本也比较低，而且也能提高用户的访问速度。 现在如果要比较CDN系统，我们可以考虑两点： CDN系统中存储静态资源服务器的性能以及网速怎么样。 CDN系统中全国甚至全球范围内服务器节点的数量以及部署情况。 第一点很好理解，第二点大家应该也能理解了，如果静态资源的服务器节点很多，能够让每个用户在访问这些静态资源时都不用“跑很远的路程”才能获取到，那么自然这是CDN系统的优点。 好，那么现在的问题是，用户在访问静态资源时也是通过域名来访问的，域名会被解析成某一个IP地址，关键的问题就是，DNS系统怎么在做域名解析时，解析出来一个离用户最近的一个IP地址呢。 普通的DNS系统是做不到的，需要一个特殊的DNS服务器，这个特殊DNS需要知道 用户当前所在位置 还需要知道用户现在访问的这个域名对应哪些IP地址，以及这个IP地址分别在哪? 对于第一个问题好解决，直接从用户请求里提取出用户的ip地址，比如这个ip地址被解析为北京电信、上海移动等等。第二个问题由谁来解决，我们现在考虑的是CDN，CDN提供商肯定知道他们公司在哪些地方部署了机器以及它们的IP地址，所以这个问题只能由CDN提供商来解决，CDN提供商会提供这个特殊的DNS服务器，我们叫做 CDN专用DNS服务器。 这样的话，只要用户在使用某个域名访问静态资源时，如果用户直接配置自己电脑的DNS地址为CDN专用DNS服务器。那么自然解决了问题，但是我们需要考虑的时，我们不能要求世界上所有的用户都去修改自己电脑的DNS地址。所以这个时候就要利用DNS中的CNAME了。 A记录：一个域名对应一个IP地址 CNAME：一个域名对应另外一个域名 NS：将子域名指定其他DNS服务器解析 用户使用某个域名来访问静态资源时（这个域名在阿里CDN服务中叫做“加速域名”），比如这个域名为“image.baidu.com”，它对应一个CNAME，叫做“cdn.ali.com”，那么普通DNS服务器（区别CDN专用DNS服务器）在解析“image.baidu.com”时，会先解析成“cdn.ali.com”，普通DNS服务器发现该域名对应的也是一个DNS服务器，那么会将域名解析工作转交给该DNS服务器，该DNS服务器就是CDN专用DNS服务器。CDN专用DNS服务器对“cdn.ali.com”进行解析，然后依据服务器上记录的所有CDN服务器地址信息，选出一个离用户最近的一个CDN服务器地址，并返回给用户，用户即可访问离自己最近的一台CDN服务器了。 以上关于转载CDN解读的参考文章原文 二、利用GitHub+jsdelivr搭建一个高速图床2.1图床的选择:接上一篇图床的推荐文章再进行一个个人评价吧！ 微博图床:没用过，有防盗链 SM.MS:稳定,经营了四年多了,但是是国外服务器,速度堪忧 大厂储存服务:例如七牛云、又拍云、腾讯云COS、阿里云OSS等，操作繁琐，又是实名认证又是域名备案的，麻烦，而且还要花钱（有钱又不怕麻烦的当我没说） Gitee图床：开启了防盗链，已经是过去式了 GitHub图床:免费，但是国内访问速度慢（不过没关系，利用 jsDelivr 提供的免费的 CDN 加速 速度足够了） 2.2关键部分：新建 GitHub 仓库生成一个 Token配置 PicGo 并使用 jsdelivr 作为 CDN 加速设定仓库名：按照用户名/图床仓库名 的格式填写设定分支名：main设定 Token：粘贴之前生成的Token指定存储路径：填写想要储存的路径，如 img/，这样就会在仓库下创建一个名为img的文件夹，图片将会储存在此文件夹中设定自定义域名：它的的作用是，在图片上传后，PicGo 会按照自定义域名+上传的图片名的方式生成访问链接，放到粘贴板上，因为我们要使用 jsDelivr 加速访问，所以可以设置为https://cdn.jsdelivr.net/gh/用户名/图床仓库名 三、此外 jsDelivr官网提供了加速访问github、npm、wordpress的使用方法这里不多赘述，可以去jsDelivr官网自行查看。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"资源","slug":"资源","permalink":"/tags/资源/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"关于gitee禁止使用图床","slug":"关于gitee禁止使用图床","date":"2022-03-28T08:05:24.000Z","updated":"2022-03-30T07:34:03.640Z","comments":false,"path":"2022/03/28/关于gitee禁止使用图床/","link":"","permalink":"/2022/03/28/关于gitee禁止使用图床/","excerpt":"","text":"最近两天，先是使用PicGo上传图片失败，查日志发现一直报403，换了个插件解决了。隔日更新博客时发现图片已经无法加载，排查到是图床的问题。前面，我一直是gitee作为图床，有点不解，又询问客服说是禁止使用来当图床的。好吧，gitee图床已经成为过去式了。 接下来分享几个免费的图床：1、路过图床 关于我们 About Us 路过图床 imgtu.com 成立于2011年，曾使用域名imgchr.com提供高速稳定的图片上传和分享服务. 我们的优势: 免费, 至少一直会保留免费套餐. 支持外链, 无限空间, 无限流量. 无需登录即可上传,最大支持10M的图片. 全球CDN加速, 提升您的图片在全球访问速度. 全站启用SSL加密链接，保障您的信息安全. 图床从2011年至今都稳定运行. 除违反TOS之外, 我们不会删除图片, 即使是多年无任何流量的图片也不会删除. 使用云存储技术, 数据实时本地和异地多重备份, 保证您的数据安全. 数据中心 美国, 加拿大, 法国, 德国, 荷兰, 新加坡, 香港, 日本 2、sm.ms 配合PicGo上传图片也很简单，注册后有5个G的空间使用。获取自己的Token，填到PicGo上接下来就可以使用了。 3、此外，这里还有一个：免费图床整理合集可以看看后面我会更新使用github图床的方法。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"资源","slug":"资源","permalink":"/tags/资源/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"【转载及推荐】JWT Token的基本使用和基本流程","slug":"【转载】JWT Token的基本使用和基本流程","date":"2022-03-18T08:31:24.000Z","updated":"2022-03-30T05:04:23.785Z","comments":false,"path":"2022/03/18/【转载】JWT Token的基本使用和基本流程/","link":"","permalink":"/2022/03/18/【转载】JWT Token的基本使用和基本流程/","excerpt":"","text":"原文链接 JWT简介JWT(json web token)是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准。 JWT的声明一般被用来在==身份提供者==和==服务提供者==间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。 基于session的登录认证在传统的用户登录认证中，因为http是无状态的，所以都是采用session方式。用户登录成功，服务端会保证一个session，当然会给客户端一个sessionId，客户端会把sessionId保存在cookie中，每次请求都会携带这个sessionId。cookie+session这种模式通常是保存在内存中，而且服务从单服务到多服务会面临的session共享问题，随着用户量的增多，开销就会越大。而JWT不是这样的，只需要服务端生成token，客户端保存这个token，每次请求携带这个token，服务端认证解析就可。 JWT生成Token后的样子eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJvcmciOiLku4rml6XlpLTmnaEiLCJuYW1lIjoiRnJlZeeggeWGnCIsImV4cCI6MTUxNDM1NjEwMywiaWF0IjoxNTE0MzU2MDQzLCJhZ2UiOiIyOCJ9.49UF72vSkj-sA4aHHiYN5eoZ9Nb4w5Vb45PsLF7x_NY JWT的构成第一部分我们称它为头部（header),第二部分我们称其为载荷（payload)，第三部分是签证（signature)。 headerjwt的头部承载==两部分==信息： 声明==类型==，这里是jwt 声明==加密的算法== 通常直接使用 HMAC SHA256 完整的头部就像下面这样的JSON： {undefined “typ”: “JWT”, “alg”: “HS256” } 然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分： eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 playload载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分 标准中注册的声明 公共的声明 私有的声明 标准中注册的声明 (建议但不强制使用) ： iss: jwt签发者 sub: jwt所面向的用户 aud: 接收jwt的一方 exp: jwt的过期时间，这个过期时间必须要大于签发时间 nbf: 定义在什么时间之前，该jwt都是不可用的. iat: jwt的签发时间 jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。 公共的声明 ： 公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密. 私有的声明 ： 私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。 定义一个payload： {undefined “name”:”Free码农”, “age”:”28”, “org”:”今日头条” } 然后将其进行base64加密，得到Jwt的第二部分： eyJvcmciOiLku4rml6XlpLTmnaEiLCJuYW1lIjoiRnJlZeeggeWGnCIsImV4cCI6MTUxNDM1NjEwMywiaWF0IjoxNTE0MzU2MDQzLCJhZ2UiOiIyOCJ9 signaturejwt的第三部分是一个签证信息，这个签证信息由三部分组成： header (base64后的) payload (base64后的) secret 这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分： 49UF72vSkj-sA4aHHiYN5eoZ9Nb4w5Vb45PsLF7x_NY 密钥secret是保存在服务端的，服务端会根据这个密钥进行生成token和验证，所以需要保护好。 java方式实现Maven依赖： &lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; 加密与校验代码： 加密方法与校验方法测试代码： 代码输出结果 可以很清楚的看到，第一次用生成的Token去校验，校验通过，并且输出了Token中包涵的信息。第二次用过期的Token调用校验方法，直接抛出异常，提示Token信息过期。 JWT总结1、因为json的通用性，所以JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用。 2、payload部分，JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。 3、便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。它不需要在服务端保存会话信息, 所以它易于应用的扩展 扩展","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"JAVA","slug":"JAVA","permalink":"/tags/JAVA/"},{"name":"后端","slug":"后端","permalink":"/tags/后端/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]},{"title":"解决端口号占用","slug":"解决端口号占用","date":"2022-03-12T03:27:24.000Z","updated":"2022-03-30T05:08:06.107Z","comments":false,"path":"2022/03/12/解决端口号占用/","link":"","permalink":"/2022/03/12/解决端口号占用/","excerpt":"","text":"问题出现于：端口号冲突，或者上一个使用端口号的进程没有关闭 随便找一个终端窗口：先根据已知端口号查询占用该端口号的进程id netstat -aon|findstr &quot;8888&quot;taskkill /f /t /im 12808","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Markdown编辑小技巧——图片篇（二）","slug":"Markdown编辑小技巧——图片篇（二）","date":"2022-03-05T02:41:24.000Z","updated":"2022-03-30T04:52:34.811Z","comments":false,"path":"2022/03/05/Markdown编辑小技巧——图片篇（二）/","link":"","permalink":"/2022/03/05/Markdown编辑小技巧——图片篇（二）/","excerpt":"","text":"插入图片编辑有时候需要对图像的位置做出调整。这里面大多是针对CSDN的，在这里的样例可能并不是很理想…. 1. 简单调整CSDN调整图片位置其实就是只需要在图片的URL后添加下面代码。代码： #pic_center #pic_right 默认就是左对齐 ![](https://img-blog.csdnimg.cn/img_convert/823c2e3f01988b470bb7abd442280f54.png) ![](https://img-blog.csdnimg.cn/img_convert/1d8e4a5c7f345360c53d205a8b2b1cc5.png#pic_center) ![](https://img-blog.csdnimg.cn/img_convert/e81621de01c32613480e92b9555e0a49.png#pic_right) 2. 使用HTML的标签&lt;img src=&quot;https://...&quot; align=right /&gt; --会与图片并列 &lt;div align=center&gt;&lt;img src=&quot;https://...&quot; &gt;&lt;img/&gt;&lt;/div&gt; --外层加个div块级标签可以解决 &lt;img src=&quot;https://...&quot; width=&quot;200&quot; height=&quot;200&quot; align=right /&gt; ---调节大小 依次： &lt;img src= &quot;https://img-blog.csdnimg.cn/img_convert/823c2e3f01988b470bb7abd442280f54.png&quot; align=right /&gt;这是一只在右边的猫！ 可以看到默认左对齐！ 所以文字在左边！ 这是一只在右边的猫！可以看到默认左对齐！所以文字在左边！ &lt;div align=center&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/823c2e3f01988b470bb7abd442280f54.png&quot; &gt;&lt;img/&gt;&lt;/div&gt;这是一只阳光的猫！ 它跑去中间了！ 文字还在原地！ 这是一只阳光的猫！它跑去中间了！文字还在原地！rust &lt;div align=center&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/823c2e3f01988b470bb7abd442280f54.png&quot; width=&quot;150&quot; height=&quot;150&quot; /&gt;&lt;img/&gt;&lt;/div&gt; &lt;div align=center&gt; 这是一只什么猫啊！ 大到模糊！文字也来中了！ &lt;/div&gt;这是一只什么猫啊！阳光到模糊！文字也来中间了！ 3. 对于从文件里导入方式以及CSDN支持的直接更改位置和大小@import &quot;01.png&quot; {width=&quot;300px&quot; height=&quot;200px&quot; title=&quot;图片的标题&quot; alt=&quot;我的 alt&quot; } ![](https://img-blog.csdnimg.cn/img_convert/fd5d71889f6f4f1a46f49df3e764421e.png#pic_center) 这样的方式在CSDN里面可以正常解析，在这里是不会正常解析的，所以还是使用html的方式更加好一些 4. 图片堆积&lt;img src=&quot;https://gitee.com/yw-7/drawing-bed/raw/master/img/cat.jpeg&quot; width=&quot;150&quot; height=&quot;150&quot; align=right /&gt;&lt;img src=&quot;https://gitee.com/yw-7/drawing-bed/raw/master/img/cat.jpeg&quot; width=&quot;150&quot; height=&quot;150&quot; align=right /&gt; &lt;img src=&quot;https://gitee.com/yw-7/drawing-bed/raw/master/img/cat.jpeg&quot; width=&quot;150&quot; height=&quot;150&quot; align=right /&gt; 可以看到如果直接使用img标签，会出现图片依次并列到右边的问题，如果标签之间加入回车 图片的位置就会变动，根据场景需要可能会不好管理，这时候需要使用div这种块级标签来解决 &lt;div align=center style=&quot;position: absolute;width:100px;height:50px;background:#FE9600;&quot;&gt;&lt;img src=&quot;https://gitee.com/yw-7/drawing-bed/raw/master/img/cat.jpeg&quot; width=&quot;50&quot; height=&quot;50&quot; /&gt;&lt;/div&gt; &lt;div align=center &gt;&lt;img src=&quot;https://gitee.com/yw-7/drawing-bed/raw/master/img/cat.jpeg&quot; width=&quot;50&quot; height=&quot;50&quot; /&gt;&lt;/div&gt; 可以看到每个div快都会独占一行，即时企图直接设置div的style属性 CSDN里的Markdown都是不会解析的中间如果不加其他块，只加回车是不会变动位置的，然而在我们的hexo配置里面，是可以设置的。 注：在这里显示的预期与CSDN上不尽相同，总结一下是因为这边有直接设置div的css选择器、同时对于类似这种url#pic_center，无法达到预期的解析结果","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"Markdown","slug":"Markdown","permalink":"/tags/Markdown/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"后端问题逐一排坑","slug":"后端问题逐一排坑","date":"2022-02-27T02:31:24.000Z","updated":"2022-03-30T05:06:58.685Z","comments":false,"path":"2022/02/27/后端问题逐一排坑/","link":"","permalink":"/2022/02/27/后端问题逐一排坑/","excerpt":"","text":"经过一番查询：解决方案就是删除掉这个.idea文件，重新加载项目发现没有项目目录解决方案如下：成功运行，第一次git提交阶段","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"JAVA","slug":"JAVA","permalink":"/tags/JAVA/"},{"name":"后端","slug":"后端","permalink":"/tags/后端/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"git提交与回退","slug":"git提交与回退","date":"2022-02-15T02:21:24.000Z","updated":"2022-04-16T15:50:47.432Z","comments":false,"path":"2022/02/15/git提交与回退/","link":"","permalink":"/2022/02/15/git提交与回退/","excerpt":"","text":"一、提交1、使用 git status 命令查看做了哪些改变如上图示，master分支修改了pom.xml，新增了四个文件 2、git add &lt;file&gt; 将改动内容提交到暂存区git add . 将所有改动提交到暂存区 3、git commit 将改动内容提交到仓库-m 提交注释 二、还原1、如果改动还未做过任何git操作git checkout -- &lt;file&gt;，还原具体文件git checkout . 还原所有改动文件 2、如果已经提交到暂存区，还未commitgit reset HEAD &lt;file&gt; 3、如果已经commit操作了git reset HEAD^ 回退到上一个版本，但修改内容保留git reset --hard HEAD^ 回退到上一个版本，修改内容不保留 三、GIT_已经提交到远程仓库的错误提交怎么修复和回退已经推到远程的分支上分某次提交发现中间有错误的信息，需要回退进行更改：步骤： 1. 重置git reset HEAD^ 2. 修改并重新commit加上新的修改并提交：git commit -m &quot;New commit message&quot; 3. 强制上传git push --force 扩展资料 github的一些常用命令介绍： 1、git init 新建一个空的仓库； 2、git status 查看状态； 3、git add . 添加文件； 4、git commit -m ‘注释’ 提交添加的文件并备注说明； 5、git remote add origin git@github.com:***/git.git 连接远程仓库； 6、git push -u origin master 将本地仓库文件推送到远程仓库； 7、git log 查看变更日志； 8、git reset –hard 版本号前六位 回归到指定版本； 9、git branch 查看分支； 10、git branch newname 创建一个叫newname的分支； 11、git checkout newname 切换到叫newname的分支上； 12、git merge newname 把newname分支合并到当前分支上； 13、git pull origin master 将master分支上的内容拉到本地上。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"解决方案","slug":"解决方案","permalink":"/tags/解决方案/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"CSDN将博客都打包成md文件~~（有点小波折）","slug":"CSDN将博客都打包成md文件~~（有点小波折）","date":"2022-02-11T00:41:24.000Z","updated":"2022-03-30T04:31:32.543Z","comments":false,"path":"2022/02/11/CSDN将博客都打包成md文件~~（有点小波折）/","link":"","permalink":"/2022/02/11/CSDN将博客都打包成md文件~~（有点小波折）/","excerpt":"","text":"最近正在进行把博客迁移到我的HEXO-github上，偶然看到了这类文章，亲测好用的一~~~~ 转载自一位大佬的文章：https://segmentfault.com/a/1190000022182081###有用到javascrip 有需求，便会有方案。 简单三步，就可以完成琐碎的活儿啦： 起初我一下释怀了，但是却这里面有个弊端，有点小失望，具体我会在后面讲述………………….. 希望你可以看完本篇文章，并且我会推荐第二种方法…………. 一、打开https://blog-console-api.csdn.net/，记得要先登入好自己的账号，页面虽然显示404但是没有关系。 二、按下F12 ， 找到控制台（console）复制下面代码上去，回车 var s=document.createElement(&#39;script&#39;);document.body.appendChild(s);s.src=&#39;//cdn.jsdelivr.net/gh/ame-yu/csdn-move@latest/dist/index.js&#39;; 三、这时你的文章就已经打包好了，直接点击下载解压就完成了！ 四、别问为什么还有个四，当我下载好之后，我以为都ok准备要去上传博客的时候却发现了……. 等等，只有两个md文件是有数据的，这和我所期待的不太一样呢，然后我就恍悟了原来在这里面呢，并没有说将CSDN种富文本编辑的文章里数据提取出来。但是也是很方便的实现了将我们使用 markdown编辑方式的文章来进行一个提取打包………. 如果要把用富文本编辑的文章也转提取出来，我们还是需要进行一个转换…于是在我的几经搜索下呢又找到了另一位大佬在某乎的文章…. 从零开发一款自动提取网页html并一键转换为md文件的工具(vue源码版) 核心思路就是：获取服务端返回的 html 串 将 html 串 转换为 md 串 同步显示预览到编辑器中 写的很详细，包含 turndown的使用技巧 vue + nuxt项目开发方式 nodejs爬虫相关应用 在其原文最后附上了实现好的github地址，体验了一下确实很赞。支持url直接转md&amp;html转md以及在线预览。 直接附上github在线链接 希望大家如果看到了这篇文章，也推荐去看看这位大佬的其他分享~","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"Markdown","slug":"Markdown","permalink":"/tags/Markdown/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"解决方案","slug":"解决方案","permalink":"/tags/解决方案/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Markdown编辑小技巧——文字篇（一）","slug":"Markdown编辑小技巧——文字篇（一）","date":"2022-02-10T12:09:24.000Z","updated":"2022-03-30T04:53:11.643Z","comments":false,"path":"2022/02/10/Markdown编辑小技巧——文字篇（一）/","link":"","permalink":"/2022/02/10/Markdown编辑小技巧——文字篇（一）/","excerpt":"","text":"1.编辑需求：撰写文章，离不开大大小小的标题、序号以及把某处段内词句强调出来，给读者更有效的视觉共鸣。先介绍常用的文字编辑方案，标题、斜体、删除线 、有序和无序标题等都会介绍。 2.文字编辑：1. 加色在CSDN上面可以，但是在这里使用这个方式的时候是不被解析的，所以还是推荐使用html方式 $\\color{#FF0000}{红}$ 其实Markdown也可以使用对应html的代码： 英文字母 这是&lt;label style=&quot;color:red&quot;&gt;红色&lt;/label&gt;字体 这是&lt;label style=&quot;color:green&quot;&gt;绿色&lt;/label&gt;字体 &lt;font color=Yellow&gt;黄色&lt;/font&gt; &lt;font color=YellowGreen&gt;黄绿色&lt;/font&gt; 这是红色字体 这是绿色字体 黄色 黄绿色 十六进制颜色值 &lt;font color=#ff0000&gt;红色&lt;/font&gt; &lt;font color=#00ff00&gt;绿色&lt;/font&gt; &lt;font color=#0000ff&gt;蓝色&lt;/font&gt; 红色绿色蓝色 2. 改变字体大小size：规定文本的尺寸大小，取值范围为1~7 ，浏览器默认值是 3。注意，size=50也是可以显示的，但与7的字体大小一样 &lt;font size=1&gt;字体大小size=1&lt;/font&gt; &lt;font size=3&gt;字体大小size=3&lt;/font&gt; &lt;font size=5&gt;字体大小size=5&lt;/font&gt; &lt;font size=5&gt;字体大小size=7&lt;/font&gt; &lt;font size=5&gt;字体大小size=50&lt;/font&gt; 字体大小size=1字体大小size=3字体大小size=5字体大小size=7字体大小size=50 3. 改变字体类型 注意，字体类型的设置只能在电脑上才能显示字体效果，在手机上无法显示字体类型 &lt;font face=&quot;黑体&quot;&gt;黑体&lt;/font&gt; &lt;font face=&quot;宋体&quot;&gt;宋体&lt;/font&gt; &lt;font face=&quot;仿宋&quot;&gt;仿宋&lt;/font&gt; &lt;font face=&quot;幼圆&quot;&gt;幼圆&lt;/font&gt; &lt;font face=&quot;楷书&quot;&gt;楷书&lt;/font&gt; &lt;font face=&quot;华文行楷&quot;&gt;华文行楷&lt;/font&gt; &lt;font face=&quot;华文隶书&quot;&gt;华文隶书&lt;/font&gt; &lt;font face=&quot;华文新魏&quot;&gt;华文新魏&lt;/font&gt; &lt;font face=&quot;华文彩云&quot;&gt;华文彩云&lt;/font&gt; &lt;font face=&quot;华文琥珀&quot;&gt;华文琥珀&lt;/font&gt; 黑体宋体仿宋幼圆楷书华文行楷华文隶书华文新魏华文彩云华文琥珀 4. 加粗、斜体、删除线**粗体文字**,__粗体文字__ 第二个缺点是在标志符前后假如添加除了符号外的字符，就会有部分显形，不太推荐 __粗体文字__123 ，你好__粗体文字__，?__粗体文字?__? 粗体文字,粗体文字粗体文字123 ，你好粗体文字，?粗体文字?? *斜体*、~~删除线~~ 斜体、删除线 5. 混合使用&lt;b&gt;&lt;font size=5 color=red face=&quot;华文彩云&quot;&gt;华文彩云&lt;/font&gt;&lt;/b&gt; 华文彩云 $\\color{#FF0000}{111111111111}$ &lt;b&gt;&lt;font size=4 color=red face=&quot;华文彩云&quot;&gt;2222222222222&lt;/font&gt;&lt;/b&gt; 2222222222222 3.文章骨架：对如上对于标题效果 的实现代码 ## 2.文章骨架： 1. 有序列表对如上对于有序列表效果 的实现代码，个人感觉针对于(一)、(1)、一、直接写就好 1. 有序列表 2. 无序列表 - 在这里插入代码片 - 在这里插入代码片 - 在这里插入代码片 对于无序列表效果 的效果 在这里插入代码片 在这里插入代码片 在这里插入代码片 3. 引用一个尖括号实现 &gt; 这里是引用 这里是引用 4. 代码块&lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; 单行情况使用“”一个点 在开头结束位置 代码块多行使用：“ `` ”使用者三个点后面加上对应的代码语言名就可以有不一样的效果并且同样以这三个点来结束 5. 超链接样例：在《 Java虚拟机规范（Java SE 8） 》中描述了JVM运行时内存区域结构如下：代码如下： 在《[Java虚拟机规范（Java SE 8）](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4)》中描述了JVM运行时内存区域结构如下： ![jvm运行时内存结构！](https://img-blog.csdnimg.cn/img_convert/1ca124a61bc51f96c66ea12fdfd0fe5f.png#pic_center) 6. 表格规范写法： |姓名|性别|学号| |-|-|-| |莱月昂|男|486| 姓名 性别 学号 莱月昂 男 486 加点空格在末尾打个竖线，看似没什么影响，但是后续再输入其他标识符就会报错，尤其是末尾不加|收尾 | 姓名 | 性别 |学号 |分数 |-|-|-----------|--------| |莱月昂 |男 |486 | 20 姓名 性别 学号 分数 莱月昂 男 486 20","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"Markdown","slug":"Markdown","permalink":"/tags/Markdown/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"jvm调优——实战","slug":"jvm调优实战","date":"2022-01-19T23:16:01.000Z","updated":"2022-03-30T04:14:27.539Z","comments":false,"path":"2022/01/20/jvm调优实战/","link":"","permalink":"/2022/01/20/jvm调优实战/","excerpt":"","text":"一些概念","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"IDEA","slug":"IDEA","permalink":"/tags/IDEA/"},{"name":"JVM","slug":"JVM","permalink":"/tags/JVM/"},{"name":"JAVA","slug":"JAVA","permalink":"/tags/JAVA/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"从jmm、jvm，到对象头、锁（长篇大论）更新中","slug":"从jmm、jvm，到对象头、锁（长篇大论）更新中","date":"2021-11-22T10:29:49.000Z","updated":"2022-03-30T05:06:11.270Z","comments":false,"path":"2021/11/22/从jmm、jvm，到对象头、锁（长篇大论）更新中/","link":"","permalink":"/2021/11/22/从jmm、jvm，到对象头、锁（长篇大论）更新中/","excerpt":"","text":"JMM(java memory model) java内存模型 Java 内存模型指定 Java 虚拟机（jvm）如何使用计算机的内存 (RAM)。Java 虚拟机是整个计算机的模型，因此该模型自然包含一个内存模型——也就是 Java 内存模型。 为什么要有内存模型在介绍Java内存模型之前，先来看一下到底什么是计算机内存模型，然后再来看Java内存模型在计算机内存模型的基础上做了哪些事情。要说计算机的内存模型，就要说一下一段古老的历史，看一下为什么要有内存模型。 内存模型，英文名Memory Model，他是一个很老的老古董了。他是与计算机硬件有关的一个概念。那么我先给你介绍下他和硬件到底有啥关系。 CPU和缓存一致性我们应该都知道，计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的数据，是存放在主存当中的，也就是计算机的物理内存啦。 刚开始，还相安无事的，但是随着CPU技术的发展，CPU的执行速度越来越快。而由于内存的技术并没有太大的变化，所以从内存中读取和写入数据的过程和CPU的执行速度比起来差距就会越来越大,这就导致CPU每次操作内存都要耗费很多等待时间。 为解决上述内存的读写速度慢与发展CPU技术的矛盾， 所以，人们想出来了一个好的办法，就是在CPU和内存之间增加高速缓存。缓存的概念大家都知道，就是保存一份数据拷贝。他的特点是速度快，内存小，并且昂贵。 当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中 而随着CPU能力的不断提升，一层缓存就慢慢的无法满足要求了，就逐渐的衍生出多级缓存。 按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可以分为一级缓存（L1），二级缓存（L2），部分高端CPU还具有三级缓存（L3），每一级缓存中所储存的全部数据都是下一级缓存的一部分。 这三种缓存的技术难度和制造成本是相对递减的，所以其容量也是相对递增的。 当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找 随着计算机能力不断提升，开始支持多线程。那么问题就来了。我们分别来分析下单线程、多线程在单核CPU、多核CPU中的影响。 单线程cpu核心的缓存只被一个线程访问。缓存独占，不会出现访问冲突等问题。 单核CPU，多线程进程中的多个线程会同时访问进程中的共享数据，CPU将某块内存加载到缓存后，不同线程在访问相同的物理地址的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。但由于任何时刻只能有一个线程在执行，因此不会出现缓存访问冲突。 多核CPU，多线程每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。 在CPU和主存之间增加缓存，在多线程场景下就可能存在缓存一致性问题，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。 处理器重排和编译器优化上面提到在在CPU和主存之间增加缓存，在多线程场景下会存在缓存一致性问题。除了这种情况，还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是处理器重排。 除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做编译器优化。 至于为什么重排，我们举个例子，假设你要运一货车苹果，现在你要把苹果装箱上车。你有两种极端的选择：装一箱子苹果，搬到货车边上，再推上去摆到车厢里……一箱一箱的依次进行；另一种方式是先全部装好箱，然后全部搬到货车边上，最后全部挪进去摆好位置。 那种效率更高？很明显是后者，因为前者你就需要不停地在装箱，搬运和上车摆放之间切换，这个切换过程不仅浪费时间，还耗费精力。但是后者一直做一个工作也很无聊，还会导致领导来检查时候车上一箱苹果也没装好，会觉得你在磨蹭摸鱼，所以比较合适的做法就是拿出来两三个箱子，把这些装好，一次多搬运几个过去。这样老板看到就会夸你很有工作效率。 再想想，如果给你多安排有两个人，一个负责装箱，一个负责搬运，一个负责装车，就更快了。 那么编译期重排序有什么好处？CPU计算的时候要访问值，如果常常利用到寄存器中已有的值就不用去内存读取了，比如说： int a = 1; int b = 1; int a = a+1; int b = b+1; 就没有如下的效果好： int a = 1; int a = a+1; int b = 1; int b = b+1; 因为后者的 a或b可能在寄存器中了。 处理器为什么要重排序？因为一个汇编指令也会涉及到很多步骤，每个步骤可能会用到不同的寄存器，CPU使用了流水线技术，也就是说，CPU有多个功能单元（如获取、解码、运算和结果），一条指令也分为多个单元，那么第一条指令执行还没完毕，就可以执行第二条指令，前提是这两条指令功能单元相同或类似，所以一般可以通过指令重排使得具有相似功能单元的指令接连执行来减少流水线中断的情况。 关于重排序分为以下三种： 编译器优化的重排序，编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 指令级并行的重排序。现代处理器采用了指令级并行技术，将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 内存系统的重排序。由于处理器使用了缓存（cpu cache）和读/写缓冲区（store buffers），使得加载和存储操作看上去可能是乱序的。 为了保证内存可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。 JMM 属于语言级的内存模型.它确保在不同的编译器和处理器平台上, 通过禁止特定类型的编译器和处理器重排序, 对外提供一致的内存可见性保证. 在多线程编程中，就涉及到线程之间的通信。为了更好的实现程序的高并发、高性能、高可用，就不得不知道JMM。至于高可用可参考https://www.linuxprobe.com/high-availability.html 并发编程的问题原子性是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 有序性即程序执行的顺序按照代码的先后顺序执行。 有没有发现，缓存一致性问题其实就是可见性问题编译器优化的重排序在不改变单线程程序语义的情况下重新安排语句的执行顺序，所以破坏了顺序性。而处理器的指令级重排序则会破坏原子性。 什么是内存模型所以，为了保证并发编程中可以满足原子性、可见性及有序性。有一个重要的概念，那就是——内存模型。 为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范 通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。 内存模型解决并发问题主要采用两种方式：限制处理器优化和使用内存屏障。 什么是Java内存模型前面介绍过了计算机内存模型，这是解决多线程场景下并发问题的一个重要规范。那么具体的实现是如何的呢，不同的编程语言，在实现上可能有所不同。 我们知道，Java程序是需要运行在Java虚拟机上面的，Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范 简要言之，jmm是jvm的一种规范，定义了jvm的内存模型。它屏蔽了各种硬件和操作系统的访问差异，不像c那样直接访问硬件内存，相对安全很多，它的主要目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。可以保证并发编程场景中的原子性、可见性和有序性。 提到Java内存模型，一般指的是JDK 5 开始使用的新的内存模型，主要由JSR-133: JavaTM Memory Model and Thread Specification描述。 Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。 而JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。 推荐看一下《JAVA并发编程的艺术》 Java内存模型的实现了解Java多线程的朋友都知道，在Java中提供了一系列和并发处理相关的关键字，比如volatile、synchronized、final、concurren包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。 在开发多线程的代码的时候，我们可以直接使用synchronized等关键字来控制并发，从来就不需要关心底层的编译器优化、缓存一致性等问题。所以，Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。 本文并不准备把所有的关键字逐一介绍其用法，因为关于各个关键字的用法，网上有很多资料。读者可以自行学习。本文还有一个重点要介绍的就是，我们前面提到，并发编程要解决原子性、有序性和一致性的问题，我们就再来看下，在Java中，分别使用什么方式来保证。 原子性在Java中，为了保证原子性，提供了两个高级的字节码指令monitorenter和monitorexit。在synchronized的实现原理文章中，介绍过，这两个字节码，在Java中对应的关键字就是synchronized。 因此，在Java中可以使用synchronized来保证方法和代码块内的操作是原子性的。 可见性Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。 Java中的volatile关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性。 除了volatile，Java中的synchronized和final两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。 有序性在Java中，可以使用synchronized和volatile来保证多线程之间操作的有序性。实现方式有所区别： volatile关键字会禁止指令重排。synchronized关键字保证同一时刻只允许一条线程操作。 好了，这里简单的介绍完了Java并发编程中解决原子性、可见性以及有序性可以使用的关键字。读者可能发现了，好像synchronized关键字是万能的，他可以同时满足以上三种特性，这其实也是很多人滥用synchronized的原因。 但是synchronized是比较影响性能的，虽然编译器提供了很多锁优化技术，但是也不建议过度使用。 jvm和jmm之间的关系JVM是对于JMM约定的具体实现方法，将内存分为五个部分，方法区，堆，JVM栈，本地方法栈，程序计数器。前两者属于线程共有，后三者属于线程私有。方法区存储类、常量、JIT即时编译的方法代码，类加载信息的引用等等。堆存储对象。JVM栈主要由方法栈帧组成，栈帧包含方法内的局部变量，操作数栈、动态链接和出口地址。本地方法是JVM本身运行的方法和调用其他语言的区域。程序计数器记录线程执行的地址，方便线程切换。 jmm中的主内存、工作内存与jvm中的Java堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机（甚至是硬件系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问读写的是工作内存。 JVM内存模型程序计数器(PC) 程序计数器是一块很小的内存空间，用于记录下一条要运行的指令。每个线程都需要一个程序计数器，各个线程之中的计数器相互独立，是线程中私有的内存空间 为什么需要程序计数器 我们知道对于一个处理器(如果是多核cpu那就是一核)，在一个确定的时刻都只会执行一条线程中的指令，一条线程中有多个指令，为了线程切换可以恢复到正确执行位置，每个线程都需有独立的一个程序计数器，不同线程之间的程序计数器互不影响，独立存储。 注意：如果线程执行的是个java方法，那么计数器记录虚拟机字节码指令的地址。如果为native【底层方法】，那么计数器为空。这块内存区域是虚拟机规范中唯一没有OutOfMemoryError的区域。 java虚拟机栈 java虚拟机栈也是线程私有的内存空间，它和java线程同一时间创建，由java语言实现的，保存了局部变量、部分结果，并参与方法的调用和返回 本地方法栈 本地方法栈和java虚拟机栈的功能相似，java虚拟机栈用于管理Java函数的调用，而本地方法栈用于管理本地方法的调用，但不是由Java实现的，而是由C实现的 java堆 为所有创建的对象和数组分配内存空间,被JVM中所有的线程共享 方法区 也被称为永久区，与堆空间相似，被JVM中所有的线程共享。方法区主要保存的信息是类的元数据，方法区中最为重要的是类的类型信息、常量池、域信息、方法信息，其中运行时常量池就在方法区，对永久区的GC回收，一是GC对永久区常量池的回收;二是永久区对元数据的回收 在JVM内部使用的java内存模型(JMM)将线程堆栈和堆之间的内存分开 根据JMM模型，在JVM把内存分成了两部分：线程栈区和堆区。 JVM中运行的每个线程都拥有自己的线程栈（也称调用栈），线程栈包含了当前线程执行的方法调用相关信息。随着代码的不断执行，调用栈会不断变化。 线程堆栈thread stack: 1.运行在java虚拟机上的每个线程都有自己的线程堆栈thread stack 2.线程堆栈还包含正在执行的每个方法的所有局部变量,一个线程只能访问它自己的线程堆栈。由线程创建的局部变量对于除创建它的线程之外的所有其他线程都是不可见的。 3.即使两个线程正在执行完全相同的代码，两个线程仍然会在每个线程堆栈中创建该代码的局部变量,一个线程可能会将一个有限变量的副本传递给另一个线程，但它不能共享原始局部变量本身 堆: 1.堆包含在Java应用程序中创建的所有对象，而不管是不是由线程创建的该对象。 2.堆中的对象可以被具有对象引用的所有线程访问。当一个线程访问一个对象时，它也可以访问该对象的成员变量。 3.如果两个线程同时调用同一个对象上的一个方法，它们都可以访问该对象的成员变量，但每个线程都有自己的局部变量副本 4.堆中的数据是共享的,线程不安全的 详细说明： 所有原始类型(boolean,byte,short,char,int,long,float,double)的局部变量都直接保存在线程栈当中，对于它们的值各个线程之间都是独立的。对于原始类型的局部变量，一个线程可以传递一个变量副本给另一个线程，但原始变量是不共享的。 堆区包含了Java应用创建的所有对象信息(包括原始类型的封装类)，不管对象是哪个线程创建的，不管对象是属于一个成员变量还是方法中的局部变量，它都会被存储在堆区。 一个局部变量如果是原始类型，那么它会被完全存储到栈区。 一个局部变量也有可能是一个对象的引用，这种情况下，这个本地引用会被存储到栈中，但是对象本身仍然存储在堆区。 对于一个对象的成员方法，这些方法中包含局部变量，仍需要存储在栈区，即使它们所属的对象在堆区。 对于一个对象的成员变量，不管它是原始类型还是包装类型，都会被存储到堆区。 Static类型的变量以及类本身相关信息都会随着类本身存储在堆区。 基于JMM的JVM模型，既然堆中的数据是共享的，那么在多线程环境中，就可能存在数据安全性问题。主要涉及到：可见性问题，竞争性问题等在此之前，回顾几个点 A、计算机常识： cpu执行的操作是原子性的，是不可拆分的。 B、造成数据安全性问题的必要条件： 多线程环境 多个线程操作共享数据 操作共享数据的语句不是原子性的（多条） 共享对象的可见性如果两个或多个线程共享一个对象，但没有正确使用volatile声明或Synchronized同步机制,一个线程更新了共享变量值后，对于其他线程来讲是不可见的。如线程A,线程B同时要进行modify, public class Account { private float balance; public void modify (float difference) { float value=this.balance; this.balance=value+difference; } } 首先，线程A和线程B在各自的thread stack中维护了一分局部变量的副本，线程A修改修改了线程A中Thread stack中的局部变量，但是还没有还没将修改的数据刷新到Main Memory中，而线程B获取的值依然是old value,就会出现问题 解决方案 使用volatile关键字 使用synchronized同步机制 tips：volatile与synchronized的区别： volatile本质是在告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取；synchronized则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住 volatile仅修饰变量；synchronized则可以修饰变量、方法、代码块 volatile仅保证可见性；synchronized则可以保证可见性和原子性 volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞 volatile修饰的变量会禁止指令重排序，因而程序不会被编译器优化；synchronized修饰的变量没有禁止指令重排序，因而程序可以被编译器优化 关于对象头，先从Java的对象模型谈起Java是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。 HotSpot虚拟机中，设计了一个OOP-Klass Model。OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。 每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个instanceKlass，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了对象头以及实例数据。 HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。java对象头很重要，synchronize、GC、HashCode、biasedLock、ObjectMonitor都是在对象头上做文章。 在JVM存储时，为了实现一些额外的功能，需要在对象中添加一些标记字段用于增强对象功能，这些标记字段组成了对象头。Mark Word：用来标记运行时信息。Class Pointer：用来指向生成该对象所在的类。如果是数组对象还得再加一项Array Length：告诉我们数组的长度。 这里以32位JVM为例： 普通对象 数组对象 Mark Word（标记字段）通过阅读open jdk官方文档中对对象头的解释可以知道，一个Java对象头中包含了2个word。第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等。第二个word是klass word，主要是指向对象的元数据 。 关于Word（字）：指的是计算机内存中占据 一个单独的内存单元编号的一组二进制串。一般32位计算机上一个字为4个字节长度。1 Byte = 8Bits。 这部分数据的长度在32位和64位的虚拟机（暂不考虑开启压缩指针的场景）中分别为32个和64个Bits，官方称它为“Mark Word”。mark word的位长度为JVM的一个Word大小，也就是说32位JVM的Mark word为32Bits，64位JVM为64Bits。（64位虚拟机情况下，markWord、class pointer、array length一般都是8字节） 考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟机 中对象未被锁定的状态下，Mark Word的32个Bits空间中的25Bits用于存储对象哈希码（HashCode），4Bits用于存储对象分代年龄，2Bits用于存储锁标志 位，1Bit固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下表所示。 其中各部分的含义如下：lock:2位的锁状态标记位，由于希望用尽可能少的二进制位表示尽可能多的信息，所以设置了lock标记。该标记的值不同，整个mark word表示的含义不同。 biased_lock：对象是否启用偏向锁标记，只占1个二进制位。为1时表示对象启用偏向锁，为0时表示对象没有偏向锁。age：4位的Java对象年龄。在GC中，如果对象在Survivor区复制一次，年龄增加1。当对象达到设定的阈值时，将会晋升到老年代。默认情况下，并行GC的年龄阈值为15，并发GC的年龄阈值为6。由于age只有4位，所以最大值为15，这就是-XX:MaxTenuringThreshold选项最大值为15的原因。identity_hashcode：25位的对象标识Hash码，采用延迟加载技术。调用方法System.identityHashCode()计算，并会将结果写到该对象头中。当对象被锁定时，该值会移动到管程Monitor中。thread：持有偏向锁的线程ID。epoch：偏向时间戳。ptr_to_lock_record：指向栈中锁记录的指针。ptr_to_heavyweight_monitor：指向管程Monitor的指针。 64位下的标记字与32位的相似： 锁有不同的分类。分别是:无锁态、偏向锁、轻量级锁 (自旋锁，自适应自旋）、重量级锁。锁的相关信息必然是要被记录的而记录的载体正是对象的对象头中的markword。此外由于存储空间的有限，为了节省空间，提高空间利用率64位虚拟机下，我们将markword这8个字节根据不同的锁状态划分成了不同的结构。其中锁状态与markword的关系入下图所示。 关于锁的介绍，具体我会在后面，详细的说明。 class pointer对象头的另外一部分是类型指针，即是对象指向它的类的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说查找对象的元数据信息并不一定要经过对象本身。另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中无法确定数组的大小。 这一部分用于存储对象的类型指针，该指针指向它的类元数据，JVM通过这个指针确定对象是哪个类的实例。该指针的位长度为JVM的一个字大小，即32位的JVM为32位，64位的JVM为64位。如果应用的对象过多，使用64位的指针将浪费大量内存，统计而言，64位的JVM将会比32位的JVM多耗费50%的内存。为了节约内存可以使用选项+UseCompressedOops开启指针压缩，其中，oop即ordinary object pointer普通对象指针。开启该选项后，下列指针将压缩至32位： 每个Class的属性指针（即静态变量） 每个对象的属性指针（即对象变量） 普通对象数组的每个元素指针 当然，也不是所有的指针都会压缩，一些特殊类型的指针JVM不会优化，比如指向PermGen的Class对象指针(JDK8中指向元空间的Class对象指针)、本地变量、堆栈元素、入参、返回值和NULL指针等。 array length如果对象是一个数组，那么对象头还需要有额外的空间用于存储数组的长度，这部分数据的长度也随着JVM架构的不同而不同：32位的JVM上，长度为32位；64位JVM则为64位。64位JVM如果开启+UseCompressedOops选项，该区域长度也将由64位压缩至32位。 附上参考资料： CompressedOops - CompressedOops - OpenJDK Wiki 实例数据（Instance Data）接下来实例数据部分是对象真正存储的有效信息，也既是我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的都需要记录下来。 这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义顺序的影响。HotSpot虚拟机 默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果 CompactFields参数值为true（默认为true），那子类之中较窄的变量也可能会插入到父类变量的空隙之中。 对齐填充（Padding） 第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。对象头正好是8字节的倍数（1倍或者2倍），因此当对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。 对象的访问定位java程序需要通过引用(ref)数据来操作堆上面的对象，那么如何通过引用定位、访问到对象的具体位置。 对象的访问方式由虚拟机决定，java虚拟机提供两种主流的方式 1.句柄访问对象 2.直接指针访问对象。(Sun HotSpot使用这种方式) 参考Java对象访问定位 句柄访问 简单来说就是java堆划出一块内存作为句柄池,引用中存储对象的句柄地址,句柄中包含对象实例数据、类型数据的地址信息。 优点:引用中存储的是稳定的句柄地址,在对象被移动【垃圾收集时移动对象是常态】只需改变句柄中实例数据的指针，不需要改动引用【ref】本身。 直接指针 与句柄访问不同的是，ref中直接存储的就是对象的实例数据,但是类型数据跟句柄访问方式一样。 优点:优势很明显，就是速度快，相比于句柄访问少了一次指针定位的开销时间。【可能是出于Java中对象的访问时十分频繁的,平时我们常用的JVM HotSpot采用此种方式】 内存溢出两种内存溢出异常[注意内存溢出是error级别的] 1.StackOverFlowError:当请求的栈深度大于虚拟机所允许的最大深度 2.OutOfMemoryError:虚拟机在扩展栈时无法申请到足够的内存空间[一般都能设置扩大] java -verbose:class -version 可以查看刚开始加载的类，可以发现这两个类并不是异常出现的时候才去加载，而是jvm启动的时候就已经加载。这么做的原因是在vm启动过程中我们把类加载起来，并创建几个没有堆栈的对象缓存起来，只需要设置下不同的提示信息即可，当需要抛出特定类型的OutOfMemoryError异常的时候，就直接拿出缓存里的这几个对象就可以了。 比如说OutOfMemoryError对象，jvm预留出4个对象【固定常量】，这就为什么最多出现4次有堆栈的OutOfMemoryError异常及大部分情况下都将看到没有堆栈的OutOfMemoryError对象的原因。 参考OutOfMemoryError解读 再说说JVM中的锁看完对象头，往下看虚拟机中对锁的一些实现，Java程序中对于多线程的同步操作并不是全部交由操作系统来完成的，JVM也会参与进来，例如遇到线程访问临界区资源但没能获得锁而等待时，JVM不会立刻让操作系统挂起线程，而是做一些例如自旋操作，让线程尽可能拿到锁，这样做的目的是尽可能提高程序运行速度，因为线程拿不到锁后进入阻塞态，等待下一次获取锁后进入就绪态再到运行态，这一系列动作需要耗费较大的性能和时间。 先来看看synchronized机制，synchronized机制有四种用法，一种是对代码块标记，第二种对静态方法进行标记，第三种对非静态方法进行标记，第四种对类进行标记。其中反编译之后可以看到，class文件中的指令通过monitorenter和monitorexit来标识代码片段是互斥的，如果是方法，方法名之前会有ACC_SYNCHRONIZED的标识。 至于底层实现，jvm通过一系列的队列来保证synchronized能够线程安全的试用。每一个对象都有一个monitor来控制是否是竞争性资源。现有的机制通过对对象头的标记来简化锁带来的负载，偏向锁，不存在竞争的线程获取资源，第二次进入不再进行同步操作。轻量锁，先尝试修改mark word的状态为轻量锁，修改成功就执行同步的代码，此时有竞争的线程自旋，自旋之后如果还不能获取到资源，锁变成重量锁。自旋锁，线程空转以免引起操作系统上下文切换。重量锁，通过synchronized机制来操作，只有在其他线程执行了monitorexit之后才能获获取资源。 vilatile 是能够保证可见性和有序性。应用场景有状态标志（开关）、双重检查锁定，在底层的实现主要依靠锁，但是vilatile并不能保证原子性，所以不是线程安全的机制。对单个volatile变量的读/写具有原子性，但是部分操作不具有，比如volatile++这样的操作 偏向锁 首先来看偏向锁，它的做法是，如果一个线程A获取了锁对象，那么这个锁对象就进入了偏向状态，Mark Word中标记为biased_lock:1 | 01，同时经过CAS无锁交换比较（compare and swap）操作后记录线程id，线程执行完释放锁之后，如果想要再次获得该锁对象，则不需要再进行加锁，cas等同步操作。当然，如果有其他线程试图去获取该锁对象时，这个偏向状态就会失效。 轻量级锁轻量级锁在JVM内部实现用的是BasicObjectLock类，类里面有轻量锁对象BasicLock，线程如果获取偏向锁失败，就会转去申请轻量级锁，轻量级锁的就是先让线程进行CAS操作来同步，期间还会将原来对象的Mark Word进行备份，然后复制BasicLock的地址到Mark Word中，如果BasicLock地址复制成功，表示线程处于轻量级锁状态，Mark Word中标记lock为00。如果地址复制失败，先会去判断线程是否之前就已经获得了锁对象，如果是就直接进入同步块，如果没有，则表明有多个线程在获取同一对象，此时轻量级锁就会膨胀成重量级锁。 关于对象头和锁之间的转换，网上大神总结 …… 关于CAS操作 参考资料： JVM内存结构 VS Java内存模型 VS Java对象模型-HollisChuang’s Blog java对象在内存中的结构（HotSpot虚拟机） - duanxz - 博客园 【Java对象解析】不得不了解的对象头_扬帆舟的博客-CSDN博客 Java对象头详解 - 追求极致 - 博客园 深入理解JVM-内存模型（jmm）和GC - 简书 JMM与JVM区别与联系（精炼总结） - it610.com","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"JVM","slug":"JVM","permalink":"/tags/JVM/"},{"name":"JAVA","slug":"JAVA","permalink":"/tags/JAVA/"},{"name":"锁","slug":"锁","permalink":"/tags/锁/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"【MySQL解决方案】Can‘t connect to MySQL server on localhost (0)","slug":"【MySQL解决方案】Can‘‘t connect to MySQL server on localhost (0)","date":"2021-11-03T01:24:01.000Z","updated":"2022-04-02T12:18:05.148Z","comments":false,"path":"2021/11/03/【MySQL解决方案】Can‘‘t connect to MySQL server on localhost (0)/","link":"","permalink":"/2021/11/03/【MySQL解决方案】Can‘‘t connect to MySQL server on localhost (0)/","excerpt":"","text":"很奇怪啊，今天突然打不开Mysql了-Windows+R电脑左下方会出现此窗口，输入services.msc回车，弹出服务窗口，然后把mysql启动就ok了。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"Mysql","slug":"Mysql","permalink":"/tags/Mysql/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"jvm调优——栈上分配","slug":"jvm的部分操作，jvm调优——栈上分配。","date":"2021-10-12T01:16:01.000Z","updated":"2022-03-30T04:15:44.751Z","comments":false,"path":"2021/10/12/jvm的部分操作，jvm调优——栈上分配。/","link":"","permalink":"/2021/10/12/jvm的部分操作，jvm调优——栈上分配。/","excerpt":"","text":"x.1 简介java虚拟机提供的一项优化技术。 基本思想即：对于那些线程私有的对象（这里指不可能被其他线程访问的对象），可以将他们打散分配在栈上，而不是分配在堆上。 好处：可以在函数调用结束后自行销毁，而不需要垃圾回收器的介入，从而提高系统的性能。 x.2 实现技术基础是进行逃逸分析。逃逸分析的目的是判断对象的作用域是否有可能逃逸出函数体。 private static User u; public static void alloc(){ u = new User(); u.id = 7; u.name = &quot;分配内存&quot;; } 对象User u 是类的成员变量，该字段有可能被任何线程访问，因此属于逃逸对象。 public static void alloc(){ User u = new User(); u.id = 7; u.name = &quot;分配内存&quot;; } 此时，对象User以局部变量的形式存在，且该对象并没有被alloc()函数返回，或者出现任何形式的公开。属于并未发生逃逸，此种情况下，虚拟机就有可能将User分配在栈上，而不在堆上。 再举示例分析： public class OnStackTest { public static class User{ public int id=0; public String name=&quot;&quot;; } public static void alloc(){ User u = new User(); u.id = 7; u.name = &quot;fpnc&quot;; } public static void main(String[] args) throws InterruptedException{ long b=System.currentTimeMillis(); for(int i=0;i&lt;100000000;i++){ alloc(); } long e=System.currentTimeMillis(); System.out.println(e-b); } } 上述代码在主函数中进行了1亿次alloc()调用来创建对象，由于这个User对象实例需要占据约16字节的空间，因此，累计分配空间将近1.5GB。如果堆内存的空间小于这个值，就必然会发生GC。 应用如下参数运行上述代码： \\-server -Xmx10m -Xms10m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-UseTLAB -XX:+EliminateAllocations 这里使用参数-server执行程序，因为在Server模式下，才可以启用逃逸分析。参数-XX:+DoEscapeAnalysis启用逃逸分析，-Xmx10m指定了堆空间最大为10MB。显然,如果对象在堆上分配，必然会引起大量的GC。如果GC真的发生了，参数-XX:+PrintGC将打印GC日志。参数-XX:+ EliminateAllocations开启了标量替换(默认打开)，允许将对象打散分配在栈上，比如对象拥有id和name两个字段,那么这两个字段将会被视为两个独立的局部变量进行分配。参数-XX:-UseTLAB关闭了TLAB。 推荐去看看这篇博主写的TLAB TLAB Thread Local Allocation Buffer 线程本地分配缓存 一个线程专用的内存分配区域，为了加速对象分配 每一个线程，都会产生一个TLAB，该线程独享的工作区域 每一个线程，都会默认使用TLAB区域 TLAB用来避免多线程冲突问题，提高对象分配效率 内存大小 TLAB空间一般不会太大 eden区放不下，优先，分配到TLAB区 TLAB区也放不下，会直接分配在堆上 JVM JVM中，创建对象的时候 TLAB区域，可以提高对象的创建效率 x.3实战环节未修改jvm参数，程序执行后，完整的输出如下: 看起来没什么问题，接着按如下操作修改这次项目的jvm参数，加上 -server -Xmx10m -Xms10m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-UseTLAB -XX:+EliminateAllocations 结果如下： 然鹅我加上我们的jvm参数，发现竟然耗时相同而且进行了两次GC，说好的优化呢？ 这里不得不说所使用的idea2021.2版，默认jvm的部分参数： -Xmx750m -XX:ReservedCodeCacheSize=512m（idea的缓存大小） -Xms128m -XX:+UseG1GC 控制变量法不能忽略呀，再次修改参数为 -Xmx10m -Xms10m -XX:+PrintGC -XX:-UseTLAB 可以明显看到，还是肥肠好用的。 此外，推荐扩展阅读： JVM调优实战总结！","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"IDEA","slug":"IDEA","permalink":"/tags/IDEA/"},{"name":"JVM","slug":"JVM","permalink":"/tags/JVM/"},{"name":"JAVA","slug":"JAVA","permalink":"/tags/JAVA/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"人家问你：什么是JVM内存结构 、 Java内存模型 、 Java对象模型？","slug":"人家问你：什么是JVM内存结构 、 Java内存模型 、 Java对象模型","date":"2021-10-09T08:56:08.000Z","updated":"2022-03-30T05:05:17.173Z","comments":false,"path":"2021/10/09/人家问你：什么是JVM内存结构 、 Java内存模型 、 Java对象模型/","link":"","permalink":"/2021/10/09/人家问你：什么是JVM内存结构 、 Java内存模型 、 Java对象模型/","excerpt":"","text":"你说：啊对对对！？ 文章出自：JVM内存结构 VS Java内存模型 VS Java对象模型-HollisChuang’s Blog JVM内存结构我们都知道，Java代码是要运行在虚拟机上的，而虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途。其中有些区域随着虚拟机进程的启动而存在，而有些区域则依赖用户线程的启动和结束而建立和销毁。 在《 Java虚拟机规范（Java SE 8） 》中描述了JVM运行时内存区域结构如下： 各个区域的功能不是本文重点，就不在这里详细介绍了。这里简单提几个需要特别注意的点： 1、以上是Java虚拟机规范，不同的虚拟机实现会各有不同，但是一般会遵守规范。 2、规范中定义的方法区，只是一种概念上的区域，并说明了其应该具有什么功能。但是并没有规定这个区域到底应该处于何处。所以，对于不同的虚拟机实现来说，是由一定的自由度的。 3、不同版本的方法区所处位置不同，上图中划分的是逻辑区域，并不是绝对意义上的物理区域。因为某些版本的JDK中方法区其实是在堆中实现的。 4、运行时常量池用于存放编译期生成的各种字面量和符号应用。但是，Java语言并不要求常量只有在编译期才能产生。比如在运行期，String.intern也会把新的常量放入池中。 5、除了以上介绍的JVM运行时内存外，还有一块内存区域可供使用，那就是直接内存。Java虚拟机规范并没有定义这块内存区域，所以他并不由JVM管理，是利用本地方法库直接在堆外申请的内存区域。 6、堆和栈的数据划分也不是绝对的，如HotSpot的JIT会针对对象分配做相应的优化。 如上，做个总结，JVM内存结构，由Java虚拟机规范定义。描述的是Java程序执行过程中，由JVM管理的不同数据区域。各个区域有其特定的功能。 Java内存模型Java内存模型看上去和Java内存结构（JVM内存结构）差不多，很多人会误以为两者是一回事儿，这也就导致面试过程中经常答非所为。 在前面的关于JVM的内存结构的图中，我们可以看到，其中Java堆和方法区的区域是多个线程共享的数据区域。也就是说，多个线程可能可以操作保存在堆或者方法区中的同一个数据。这也就是我们常说的“Java的线程间通过共享内存进行通信”。 Java内存模型是根据英文Java Memory Model（JMM）翻译过来的。其实JMM并不像JVM内存结构一样是真实存在的。他只是一个抽象的概念。JSR-133: Java Memory Model and Thread Specification中描述了，JMM是和多线程相关的，他描述了一组规则或规范，这个规范定义了一个线程对共享变量的写入时对另一个线程是可见的。 那么，简单总结下，Java的多线程之间是通过共享内存进行通信的，而由于采用共享内存进行通信，在通信过程中会存在一系列如可见性、原子性、顺序性等问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。 在Java中，JMM是一个非常重要的概念，正是由于有了JMM，Java的并发编程才能避免很多问题。这里就不对Java内存模型做更加详细的介绍了，想了解更多的朋友可以参考《Java并发编程的艺术》。 Java对象模型Java是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。 HotSpot虚拟机中，设计了一个OOP-Klass Model。OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。 每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个instanceKlass，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了对象头以及实例数据。 这就是一个简单的Java对象的OOP-Klass模型，即Java对象模型。 【理解HotSpot虚拟机】对象在jvm!链机制,建议将下的表示：OOP-Klass模型接nxd(CSDi博客_klass 总结我们再来区分下JVM内存结构、 Java内存模型 以及 Java对象模型 三个概念。 JVM内存结构，和Java虚拟机的运行时区域有关。 Java内存模型，和Java的并发编程有关。 Java对象模型，和Java对象在虚拟机中的表现形式有关。 后面我会将本文中所引申的内容整理分享出来。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"JVM","slug":"JVM","permalink":"/tags/JVM/"},{"name":"JAVA","slug":"JAVA","permalink":"/tags/JAVA/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Mysql调优(一)","slug":"Mysql调优（一）","date":"2021-09-20T14:37:26.000Z","updated":"2022-03-30T04:53:42.578Z","comments":false,"path":"2021/09/20/Mysql调优（一）/","link":"","permalink":"/2021/09/20/Mysql调优（一）/","excerpt":"","text":"一、执行计划:Explain查询下面三个重要相关的列:Type/Key/exture 引一下比较不错的解释： Type列: possible_key列 + key列： exture列此字段显示一些额外的信息，但是此字段的部分值具有优化的参考意义。 （1）using where：表示查询使用了where 语句来处理结果 （2）using index：表示使用了覆盖索引。这个值重点强调了只需要使用索引就可以满足查询表的要求，不需要直接访问表数据。 （3）using join buffer：这个值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进性能 （4）using filesort：这是 order by 语句的结果。这可能是一个CPU密集型的过程。using filesort表示出现了文件内排序，表示很不好的现象，必须要优化，特别是大表，可以通过选择合适的索引来改进性能，用索引来为查询结果排序。 （5）using temporary：mysql需要创建一张临时表来保存中间结果。 也就是说，需要先把数据放到临时表中，然后从临时表中获取需要的数据。出现这种临时表，也是必须需要优化的地方，特别是数据量大的情况。两个常见的原因是在来自不同表的列上使用了distinct，或者使用了不同的 order by 和 group by 列。 二、索引2.1.MySQL的索引数据和实际数据都存储在磁盘，而非内存2.2.当启动数据库服务时，才将数据库的索引文件读取(加载)到内存中去。2.3.分块进行数据读取.(索引和数据量都非常大，内存放不下)(页的整数倍) 涉及到部分操作系统知识：【局部性原理时间局部性:之前被访问的数据，很有可能很快被再次访问空间局部性:数据和程序都有聚集成群的倾向，具备某些特征的数据可以放在一起磁盘预读:内存和磁盘在进行交互的时候，有一个最基本的逻辑单位，称为页，也叫datapage，大小一般是4k或者8k，我们在进行数据读取的时候，一般读取的是页的整数倍innodb默认页大小16k】 2.4.考虑数据结构存储(格式:K-V)。2.4.1 哈希表(memory,heap在内存中，innodb自适应哈希): 特点：哈希冲突、散列(均等分在对应的数组下标下)、如果某一位置的链表过长，那么造成空间上的浪费，就需要更好的哈希算法优化(jdk1.8以后，扰动函数：让二进制高位参加运算)。无序，范围查询效率非常低，只能挨个遍历。 【 innodb引擎四大特性概要:1.插入缓冲(insertBuffer/ChangeBuffer)提升插入性能。change-buffering，是insert-buffer的加强，insert-buffer只针对insert有效，change-buffering对insert、delete、update（delete+insert）、purge都有效。 只对于非聚集索引（非唯一)的插入和更新有效。对于每一次的插入，不是写到索引页中。而是先判断插入的非聚集索引页是否在缓冲池中，如果在，则直接插入；若不在，则先放到insert-buffer,再按照一定的频率进行合并操作，在写回disk。这样通常能将多个插入合并到一个操作中。目的还是为了减少随机IO带来性能损耗。 使用插入缓冲的条件：* 非聚集索引* 非唯一索引 2.二次写（double-write）Double-write缓存是位于系统表空间的存储区，用来缓存innodb的数据页，从innodb-buffer-pool中,-Flush之后，并写入到数据文件之前，所以当操作系统或者数据库进程在数据页写磁盘的过程中崩溃。innodb也可以在double-write的缓存中找到数据页的备份儿，用来执行crash恢复。数据页写入到double-write缓存的动作所需要的IO消耗要小于写入到数据文件的消耗。因此写入操作会以一次大的连续块的方式写入。 3.自适应哈希（ahi）条件比较苛刻。一，所索引是否被访问了17次。二、索引中的某个页已经被访问了100次。三、访问模式必须是一样的。 4.预读（read-ahead）InnoDB使用两种预读算法来提高I/O性能：线性预读（linear read-ahead）和随机预读（randomread-ahead） 】 这里只是部分介绍：具体推荐去看这篇博主。 2.4.2 B+树: 推荐跳过去看，为什么MySQL的索引使用B+树，在此处不加赘述。 带着几个问题去看吧：为什么使用B+树？解决了什么问题？B+树与B-树的区别，相对于存储数据，B+树的结构优化了哪些？对查询等操作效率的影响？数据在磁盘的存取过程中，数据缺失问题减少的原因是否与B+树的链表有关？ 2.5.IO层面减少io次数，减少io量2.6.数据迁移关掉索引尽量自增","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"},{"name":"Mysql","slug":"Mysql","permalink":"/tags/Mysql/"},{"name":"IDEA","slug":"IDEA","permalink":"/tags/IDEA/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"【Spring】Spring中的Bean是线程安全的吗？","slug":"【Spring】Spring中的Bean是线程安全的吗？","date":"2021-07-15T13:39:54.000Z","updated":"2022-04-05T12:18:02.967Z","comments":false,"path":"2021/07/15/【Spring】Spring中的Bean是线程安全的吗？/","link":"","permalink":"/2021/07/15/【Spring】Spring中的Bean是线程安全的吗？/","excerpt":"","text":"结论：Spring中的Bean是否线程安全，跟Spring容器本身无关。Spring中的Bean本身也不具备线程安全的特性。 Spring中的Bean从哪里来的？除了Spring中内置的，其他的Bean我们自己通过Spring配置来声明的，然后由Spring容器来统一进行加载。 Spring声明配置中通常会配置以下内容：比如： class（全类名） id（也就是Bean的唯一标识） scope（作用域） lazy-init（是否延时加载） 等等之后Spring容器会根据这些配置内容来使用对应的策略来进行创建实例，因此，Spring中的Bean都是根据我们自己写的类来创建的实例，Spring中的Bean是否线程安全，跟Spring容器本身无关。只是交给Spring容器托管而已。Spring容器中什么样的Bean会存在线程安全问题？Spring Bean的作用域： prototype（多例Bean）每次getBean的时候都会创建一个新的对象实例也就是线程之间不存在Bean共享的问题，多例Bean是不存在线程共享问题的。 singleton（单例Bean）在Spring容器中只会存在一个全局共享的实例因此可能会存在线程安全问题。单例Bean又分为： 无状态Bean多线程操作中，只会对Bean的成员变量进行查询操作，不会修改成员变量的值 有状态Bean 多线程操作中，如果需要对Bean中的成员变量进行数据更新操作，可能存在线程安全问题 如何处理有状态Bean的线程安全问题？ 将 “singleton” 改为 “prototype” 避免定义可变的成员变量 在类中定义ThreadLocal的成员变量，并将需要的可变成员变量，保存在ThreadLocal中，ThreadLocal本身具备线程隔离的特性，这就相当于为每个线程提供了一个独立的变量副本，每个线程只需要操作自己的线程变量副本，从而解决线程安全问题。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"IDEA","slug":"IDEA","permalink":"/tags/IDEA/"},{"name":"web","slug":"web","permalink":"/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"阿里云OSSUtil在win环境下的使用","slug":"阿里云OSSUtil在win环境下的使用","date":"2021-06-27T01:45:24.000Z","updated":"2022-03-30T04:03:15.822Z","comments":false,"path":"2021/06/27/阿里云OSSUtil在win环境下的使用/","link":"","permalink":"/2021/06/27/阿里云OSSUtil在win环境下的使用/","excerpt":"","text":"Ossutil工具：1.Ossutil简介：命令行管理工具。提供方便、简洁、丰富的Object管理命令。简单来讲就是通过简单的命令行，即可实现数据往OSS上传输的功能，当然也包括其他的功能。 2.下载与安装：进入阿里云官网 下载安装包https://help.aliyun.com/document_detail/50452.html?spm=a2c4g.11186623.6.1054.KQWN6E 3. 安装使用windows系统下有两种方法（以64位系统为例）： 1) 解压压缩包，双击运行其中的bat文件，再键入：ossutil64.exe 2）解压压缩包，cmd进入压缩包中binary所在的目录，键入：ossutil64.exe 4.配置工具config文件在使用访问oss的命令时，需要先配置访问AK，关于AK的更多信息见：RAM和STS介绍配置ossutil由两种方式：交互式和非交互式。关于配置命令的更多帮助，请使用ossutil help config查看。交互式配置ossutil ./ossutil config 1. $./ossutil config -L ch 2. 该命令创建将一个配置文件，在其中存储配置信息。 3. 4. 请输入配置文件路径（默认为：/home/admin/.ossutilconfig，回车将使用默认路径。如果用户设置为其它路径，在使用命令时需要将--config-file选项设置为该路径）： 非交互式配置ossutil ./ossutil config -e oss.aliyuncs.com -i your_id -k your_key 1. 配置文件格式： 2. 3. [Credentials] 4. language = CH 5. endpoint = oss.aliyuncs.com 6. accessKeyID = your_key_id 7. accessKeySecret = your_key_secret 8. stsToken = your_sts_token 9. outputDir = your_output_dir 10. [Bucket-Endpoint] 11. bucket1 = endpoint1 12. bucket2 = endpoint2 13. ... 14. [Bucket-Cname] 15. bucket1 = cname1 16. bucket2 = cname2 17. ... 18. 19. SAMPLE 20. 21. ossutil config 22. ossutil config -e oss-cn-hangzhou.aliyuncs.com -c ~/.myconfig 23. 24. OPTIONS 25. 26. -c, --config-file 27. ossutil工具的配置文件路径，ossutil启动时从配置文件读取配置，在config命令中，ossutil将配置写入该文件。 28. 29. -e, --endpoint 30. ossutil工具的基本endpoint配置（该选项值会覆盖配置文件中的相应设置），注意其必须为一个二级域名。 31. 32. -i, --access-key-id 33. 访问oss使用的AccessKeyID（该选项值会覆盖配置文件中的相应设置）。 34. 35. -k, --access-key-secret 36. 访问oss使用的AccessKeySecret（该选项值会覆盖配置文件中的相应设置）。 37. 38. -t, --sts-token 39. 访问oss使用的STSToken（该选项值会覆盖配置文件中的相应设置），非必须设置项。 40. 41. --output-dir=ossutil_output 42. 指定输出文件所在的目录，输出文件目前包含：cp命令批量拷贝文件出错时所产生的report文件（关于report文件更多信息，请参考cp命令帮助）。默认值为：当前目录下的ossutil_output目录。 43. 44. -L CH, --language=CH 45. 设置ossutil工具的语言，默认值：CH，取值范围：CH/EN，若设置成&quot;CH&quot;，请确保您的系统编码为UTF-8。 5.开通OSS 5.创建存储空间bucket Bucket名称 存储类型 同城冗余存储适用于：对于“恢复时间目标(RTO)”以及“恢复点目标(RPO)”有较高要求Bucket内的数据会冗余存储在同一个区域的3个可用区中数据可用性更高但存储费用也会相应提高支持标准存储和低频访问 版本控制适用于：对数据安全有更高要求Bucket内被覆盖或者被删除的文件会转为历史版本可以随时恢复历史版本文件 读写权限 服务端加密方式 实时日志查询适用于：需要实时查询与分析Bucket的访问数据目前可免费查询7天内并且每天不超过900GB的日志超出限额产生费用 定时备份开通后两个月内可免费使用 6.创建bucket文件夹指定目录不存在会自动创建","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"【从零开始的Springboot学习（三）】SpringBoot中的默认配置","slug":"【从零开始的Springboot学习（三）】SpringBoot中的默认配置","date":"2021-06-04T01:42:29.000Z","updated":"2022-04-02T12:58:44.398Z","comments":false,"path":"2021/06/04/【从零开始的Springboot学习（三）】SpringBoot中的默认配置/","link":"","permalink":"/2021/06/04/【从零开始的Springboot学习（三）】SpringBoot中的默认配置/","excerpt":"","text":"这些默认配置怎么配置的，在哪里配置的？ 同样也可以找到一些springmvc的一些配置 通过我们的导入的包spring-boot-autoconfigure里面，来自动配置 为何依赖引入就会触发配置呢？引入依赖，然后满足上面个个类所约定的条件，就会自动配置 这些默认配置属性来自哪里？比如 视图解析器是有前缀和后缀的属性在哪里？可以看到，这各mvcProperties就是根据构造方法注入资源配置读取类，读取”spring.mvc”开头的配置 总结springboot为我们提供了默认配置，而默认配置生效的条件一般有两个： 引入了相关依赖 自己没有配置（一般情况我们会进行覆盖默认配置） 启动器每一个启动器后面都是一堆依赖，可以参考官方文档的对应章节starters去搜索对应的启动器。 全局配置springboot的默认配置文件只有application.properties或者application.yml文件，只能存在一个","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"IDEA","slug":"IDEA","permalink":"/tags/IDEA/"},{"name":"web","slug":"web","permalink":"/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"【从零开始的Springboot学习（二）】属性注入方法对比，以及SpringBoot是如何优化的","slug":"【从零开始的Springboot学习（二）】属性注入方法对比，以及SpringBoot是如何优化的","date":"2021-06-03T10:09:35.000Z","updated":"2022-04-02T12:54:29.463Z","comments":false,"path":"2021/06/03/【从零开始的Springboot学习（二）】属性注入方法对比，以及SpringBoot是如何优化的/","link":"","permalink":"/2021/06/03/【从零开始的Springboot学习（二）】属性注入方法对比，以及SpringBoot是如何优化的/","excerpt":"","text":"查看源码的注解接上一篇，我们写了一个简单demo后，可以通过： 按住ctrl键，点击某个方法、注解，进去源码之后，右上角会出现下载源码，点击下载，之后就可以看到英文的注释，接着在对应方法、注解上按ctrl+q 可以看到对应注释 @EnableAutoConfiguration就是先根据classpath引入了哪些依赖，然后猜测你要使用哪些配置，然后自动配置。 如果多个controller应该如何操作：就是main方法不能出现在controller里面，一个端口不能启动两个tomcat，也就不能启动两个main方法，应该独立出来；自动配置也是一样，启动一次就可以 SpringBoot引入一个全局的引导类（放到基包下，是springboot应用入口） @EnableAutoConfiguration//启动springboot应用的自动配置 @ComponentScan //类似于&lt;context:componnet-scan base-package=&quot;&quot;&gt; public class TextApplication { public static void main(String[] args) { SpringApplication.run(TextApplication.class,args); } } @ComponentScan配置组件扫描，类似于context:componnet-scan，可以通过指定base-package的值来扫描特定的包；如果未指定，会从这个类所在包进行扫描，以及它所包含的所有包。 使用@SpringBootApplication优化注解组合注解，相当于@EnableAutoConfiguration+@ComponentScan+@SpringBootConfiguration @SpringBootConfiguration相当于@Configuration注解声明一个类是java配置类 应用应该只能包含一个@SpringBootConfiguration，这个注解已经在组合注解内部了，也就是后面无需自己添加。 默认配置原理SpringBoot的默认配置方式无序任何的xml。 发展 通过配置一个德鲁伊（Druid）连接池来进行一个对比：先添加pom依赖 &lt;dependency&gt; &lt;groupId&gt;com.github.drtrang&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot2-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; 创建一个config包，添加JdbcConfiguration类 @Configuration //声明一个类是一个java配置类，相当于一个xml配置文件 public class JdbcConfiguration { @Bean //将方法的返回值注入给spring容器 public DataSource dataSource(){ new DruidDataSource().var //idea快捷补全代码小技巧 return } } new DruidDataSource().var +table键 这里可以通过这样的方式idea会自动补全代码 如下DruidDataSource dataSource = new DruidDataSource(); @Configuration //声明一个类是一个java配置类，相当于一个xml配置文件 public class JdbcConfiguration { @Bean //将方法的返回值注入给spring容器 public DataSource dataSource(){ DruidDataSource dataSource = new DruidDataSource(); //设置四大参数，这里不写死，先去添加资源文件 dataSource.setDriverClassName(); dataSource.setUrl(); dataSource.setUsername(); dataSource.setPassword(); return } } 添加资源文件 jdbc.driverClassName=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://127.0.0.1:65535:21sb jdbc.username=root jdbc.password=123456 接着完善JdbcConfiguration这里使用@Value(“${}”)来引入资源文件的值@Bean将方法的返回值dataSource注入到spring容器 @Configuration //声明一个类是一个java配置类，相当于一个xml配置文件 @PropertySource(&quot;classpath:jdbc.properties&quot;)//读取资源文件 public class JdbcConfiguration { @Value(&quot;${jdbc.driverClassName}&quot;) private String driverClassName; @Value(&quot;${jdbc.url}&quot;) private String url; @Value(&quot;${jdbc.username}&quot;) private String username; @Value(&quot;${jdbc.password}&quot;) private String password; @Bean //将方法的返回值注入给spring容器 public DataSource dataSource(){ DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(this.driverClassName);//加this代表这是全局变量 dataSource.setUrl(this.url); dataSource.setUsername(this.username); dataSource.setPassword(this.password); return dataSource; } } 再到HelloController类我们使用@Autowired的方式来注入dataSource属性 @RequestMapping(&quot;hello2&quot;) @RestController//@Controller+@ResponseBody 返回的是json的数据 @EnableAutoConfiguration//自动配置 public class HelloController2 { @Autowired private DataSource dataSource; @GetMapping(&quot;show2&quot;) public String test(){ return &quot;hello springboot2&quot;; } } 接着打一个断点，进行debug 回到调试点开this向下面划找到我们注入的四大参数spring底层就是基于java的配置方式来进行注入的。 可以看到，这里面dataSource属性如果在其他类就不能使用了，需要再次注入了，存在代码冗余问题。 springboot的方案是：定义一个属性读取类我们创建一个JdbcProProperties类加上@ConfigurationProperties注解报红了，没有关系直接关掉这个提示 @ConfigurationProperties点开这个注解： 发现这里的注入方式是与前缀有关的，但是这个注解提供读取资源文件的功能当我们SpringBoot程序启动的 时候会读取一个application.properties的文件，这也是我们放所有配置的文件。然鹅，如何区分这里哪些是jdbc的配置哪些是其他的呢？就是根据我们这个@ConfigurationProperties注解里的前缀属性prefix=&quot;&quot;来区分了 @ConfigurationProperties(prefix = &quot;jdbc&quot;) public class JdbcProProperties { //这里已经不需要@Value注解了 private String driverClassName; private String url; private String username; private String password; //通过alt+ins 快速生成 get和set方法 public String getDriverClassName() { return driverClassName; } public void setDriverClassName(String driverClassName) { this.driverClassName = driverClassName; } public String getUrl() { return url; } public void setUrl(String url) { this.url = url; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } } 定义相应属性之后，通过set()方法来设置相应参数，注意set属性字段名一定要和资源文件里面的一致否则，读取不到。 回到JdbcConfiguration中填加：启用属性读取类的注解@EnableConfigurationProperties(JdbcProProperties.class)接下来去掉多余注解：//@PropertySource(“classpath:jdbc.properties”)//注入属性的地方 改为 使用@Autowrid注入JdbcProProperties这个属性读取类 SpringBoot的第一个注入方法：@Configuration //声明一个类是一个java配置类，相当于一个xml配置文件 //@PropertySource(&quot;classpath:jdbc.properties&quot;)//读取资源文件 @EnableConfigurationProperties(JdbcProProperties.class) public class JdbcConfiguration { @Autowired private JdbcProProperties jdbcProProperties; /* @Value(&quot;${jdbc.driverClassName}&quot;) private String driverClassName; @Value(&quot;${jdbc.url}&quot;) private String url; @Value(&quot;${jdbc.username}&quot;) private String username; @Value(&quot;${jdbc.password}&quot;) private String password;*/ @Bean //将方法的返回值注入给spring容器 public DataSource dataSource(){ DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(this.jdbcProProperties.getDriverClassName());//加this代表这是全局变量 dataSource.setUrl(this.jdbcProProperties.getUrl()); dataSource.setUsername(this.jdbcProProperties.getUsername()); dataSource.setPassword(this.jdbcProProperties.getPassword()); return dataSource; } } 再次进行debug结果如下： 第二个注入方法：不使用@Autowrid注解采用构造方法的方式 @Configuration //声明一个类是一个java配置类，相当于一个xml配置文件 //@PropertySource(&quot;classpath:jdbc.properties&quot;)//读取资源文件 @EnableConfigurationProperties(JdbcProProperties.class) public class JdbcConfiguration { // @Autowired private JdbcProProperties jdbcProProperties; public JdbcConfiguration(JdbcProProperties jdbcProProperties){ this.jdbcProProperties = jdbcProProperties; } /* @Value(&quot;${jdbc.driverClassName}&quot;) private String driverClassName; @Value(&quot;${jdbc.url}&quot;) private String url; @Value(&quot;${jdbc.username}&quot;) private String username; @Value(&quot;${jdbc.password}&quot;) private String password;*/ @Bean //将方法的返回值注入给spring容器 public DataSource dataSource(){ DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(this.jdbcProProperties.getDriverClassName());//加this代表这是全局变量 dataSource.setUrl(this.jdbcProProperties.getUrl()); dataSource.setUsername(this.jdbcProProperties.getUsername()); dataSource.setPassword(this.jdbcProProperties.getPassword()); return dataSource; } } 依然是可以读取到对应的参数的 第三个注入方法：直接通过bean方法的形参来配置 @Configuration //声明一个类是一个java配置类，相当于一个xml配置文件 //@PropertySource(&quot;classpath:jdbc.properties&quot;)//读取资源文件 @EnableConfigurationProperties(JdbcProProperties.class) public class JdbcConfiguration { @Bean //将方法的返回值注入给spring容器 public DataSource dataSource(JdbcProProperties jdbcProProperties){ DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(jdbcProProperties.getDriverClassName());//加this代表这是全局变量 dataSource.setUrl(jdbcProProperties.getUrl()); dataSource.setUsername(jdbcProProperties.getUsername()); dataSource.setPassword(jdbcProProperties.getPassword()); return dataSource; } } 结果依然没有问题 第四个注入方法：也是最精简的方法 @Configuration //声明一个类是一个java配置类，相当于一个xml配置文件 public class JdbcConfiguration { @Bean //将方法的返回值注入给spring容器 @ConfigurationProperties(prefix = &quot;jdbc&quot;) public DataSource dataSource(){ DruidDataSource dataSource = new DruidDataSource(); return dataSource; } } @ConfigurationProperties这个注解在类上的时候，会调用类的set()方法注入参数，在方法上也一样，会调用DataSource的set()方法，也会注入。debug依然ok的。 SpringBoot的四种属性注入方法总结： @Autowrid注入 构造方法注入 @Bean方法形参注入 直接在@Bean方法上使用@ConfigurationProperties(prefix = “jdbc”) 第四种看起来很好，但是需要保证： 返回值(上面的dataSource)有相应的set()方法 资源文件配置要和属性名一致有一定的局限性。 平常使用最多的是第一种方法。 这两篇文章所包含的注解","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"IDEA","slug":"IDEA","permalink":"/tags/IDEA/"},{"name":"web","slug":"web","permalink":"/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"【从零开始的Springboot学习（一）】入门demo","slug":"【从零开始的Springboot学习（一）】入门demo","date":"2021-06-02T02:37:29.000Z","updated":"2022-04-02T12:49:25.266Z","comments":false,"path":"2021/06/02/【从零开始的Springboot学习（一）】入门demo/","link":"","permalink":"/2021/06/02/【从零开始的Springboot学习（一）】入门demo/","excerpt":"","text":"打开官网https://spring.io/ Spring Boot makes it easy to create stand-alone, production-gradeSpring based Applications that you can “just run”. 使用springboot搭建应用只需要打成jar包，然后执行 java -jar xxxx.jar命令 We take an opinionated view of the Spring platform and third-partylibraries so you can get started with minimum fuss. Most Spring Bootapplications need minimal Spring configuration. 大多数 Spring Boot 应用程序需要最少的 Spring 配置。 Features Create stand-alone Spring applications——独立的 Spring 应用程序 Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files)——内置servlet容器，不需要部署war包 Provide opinionated ‘starter’ dependencies to simplify your build configuration——提供固定化起动器依赖，简化配置 Automatically configure Spring and 3rd party libraries whenever possible——尽可能自动配置Spring库和第三方库 Provide production-ready features such as metrics, health checks, and externalized configuration——提供生产水平功能：健康监测、监控等 Absolutely no code generation and no requirement for XML configuration——无需代码生成以及XML配置 为什么学习Springboot？内置tomcat，提供自动配置，搭建spring应用的脚手架，解决了： 复杂的配置——配置xml 混乱的依赖管理——导jar包 打开参考文档去阅读学习 创建maven项目，添加pom依赖这里需要注意 版本问题maven版本、jdk版本是当前支持的版本这里以maven3.8.2，jdk1.8为例 完整pom代码 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.ywq&lt;/groupId&gt; &lt;artifactId&gt;relspringboot&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 所有springboot应用都要以该工程为父工程 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.7.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;!-- 启动器：每一个启动器背后都是一堆的依赖 web启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 创建controller文件 @RequestMapping(&quot;hello&quot;) @RestController//@Controller+@ResponseBody 返回的是json的数据 @EnableAutoConfiguration//自动配置 public class HelloController { @GetMapping(&quot;show&quot;) public String test(){ return &quot;hello springboot&quot;; } public static void main(String[] args) { SpringApplication.run(HelloController.class,args); } } 运行main方法可以看到默认端口是8080，在浏览器打开如下：","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"IDEA","slug":"IDEA","permalink":"/tags/IDEA/"},{"name":"web","slug":"web","permalink":"/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"【计网】TCP协议20问（四）","slug":"【计网】TCP协议（四）","date":"2021-03-18T00:25:24.000Z","updated":"2022-03-30T05:04:01.699Z","comments":false,"path":"2021/03/18/【计网】TCP协议（四）/","link":"","permalink":"/2021/03/18/【计网】TCP协议（四）/","excerpt":"","text":"16、netstat的用法显示所有相关套接字的信息，包括监听和未监听的（ 套接字(Socket)：对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口，是应用程序与网络协议栈进行交互的接口。要通过互联网进行通信，至少需要一对套接字，其中一个运行于客户端，我们称之为 Client Socket，另一个运行于服务器端，我们称之为 Server Socket 。套接字Socket=（IP地址：端口号），套接字的表示方法是点分十进制的lP地址后面写上端口号，中间用冒号或逗号隔开。每一个传输层连接唯一地被通信两端的两个端点（即两个套接字）所确定。例如：如果IP地址是210.37.145.1，而端口号是23，那么得到套接字就是(210.37.145.1:23)） 17、tcpdump的用法tcpdump 是一个命令行的网络流量分析工具，功能十分强大，一般我们用来抓TCP的包。使用curl命令这里面可以看出三次握手和四次挥手： 前面是在Linux上的抓包演示，在Windows上可以使用Wireshark工具在win下建立一个连接可以看到tcp的网络分层 19、TCP和UDP的区别","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"【计网】TCP协议20问（三）","slug":"【计网】TCP协议（三）","date":"2021-03-02T04:31:24.000Z","updated":"2022-03-30T05:02:25.798Z","comments":false,"path":"2021/03/02/【计网】TCP协议（三）/","link":"","permalink":"/2021/03/02/【计网】TCP协议（三）/","excerpt":"","text":"11、聊一聊TCP中的端口号端口号的英文叫Port，英文原意是“港口，口岸”的意思 TCP用两个字节的整数来表示端口，一台主机最大允许65536个端口号 12、TCP场景问题1 13、TCP场景问题2 14、TCP场景问题3不同的程序有不同的表示边界方式。 15、telnet的用法在linux系统上为例：模拟一个百度的协议发送，然后得到一个百度的首页。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"【计网】TCP协议20问（二）","slug":"【计网】TCP协议（二）","date":"2021-02-04T04:31:24.000Z","updated":"2022-03-30T05:03:20.020Z","comments":false,"path":"2021/02/04/【计网】TCP协议（二）/","link":"","permalink":"/2021/02/04/【计网】TCP协议（二）/","excerpt":"","text":"6、说说TCP快速打开（TFO）的原理TCP快速打开（TCP Fast Open，TFO）TFO是在原来TCP协议上的扩展协议，它的主要原理就是在发送第一个SYN包的时候就开始传递数据了，不过它要求当前客户端之前已经完成过正常的三次握手。快速打开分两个阶段：请求Fast Open Cookie和真正的TCP Fast Open 7、TCP报文中的时间戳有什么作用？ 8、TCP的超时重传时间是如何计算的？ 9、说一说TCP的流量控制？ 10、如何理解TCP的keep-alive的原理？","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"【计网】TCP协议20问（一）","slug":"【计网】TCP协议（一）","date":"2021-01-17T08:31:24.000Z","updated":"2022-03-30T05:01:41.051Z","comments":false,"path":"2021/01/17/【计网】TCP协议（一）/","link":"","permalink":"/2021/01/17/【计网】TCP协议（一）/","excerpt":"","text":"1、什么是TCP网络分层？ 2、TCP的三次握手中为什么是三次？不是两次四次？3、TCP的四次挥手为什么是四次？为什么不是三次？互相发送四个报文，那么第二、三次可以合成一次报文发送吗？不可以。第二次是服务端收到客户端请求马上做出应答：ACK=x+3，在这之后服务端可能要处理之前客户端发送的数据请求，需要相当长一段时间的延迟、时差（超过一分钟或者更久）发送时间是要以处理完成后的时间点相应给客户端。客户端等待超过了30s或者其他超时时间，作为TCP协议（TCP是面向可靠的，它通过重发的机制来确保报文的可达性），他会进行一次次的重发。如果合成三次挥手，ACK的确认和FIN的确认存在时差的，会导致客户端发过去的FIN请求不断的重发，会造成资源的浪费。所以需要四次就能达到两端的确认的效果。 4、为什么SYN/FIN不包含数据却要消耗一个序列号？凡是需要对端确认的，一定消耗TCP报文的序列号。不然的话可能会因为网络的原因，SYN进行了重发了多次，服务端就会对你的重复数据进行处理。 SYN和FIN需要对端的确认，所以需要消耗一个序列号。用来去防止重复或者是使调用有一个顺序性。 三次握手里面，客户端发送的SYN需要序列号四次挥手里面，这个FIN都需要去消耗一个序列号。 5、什么是半连接队列？什么是SYN Flood攻击？SYNFlood也叫“洪泛攻击”洪泛攻击，在短时间内向目标系统发送大量的虚假请求的攻击方式。导致目标系统疲于应付无用信息，而无法为合法用户提供正常服务。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2020-12-12T14:16:01.000Z","updated":"2022-03-30T07:39:20.761Z","comments":false,"path":"2020/12/12/Hexo-Theme-Sakura/","link":"","permalink":"/2020/12/12/Hexo-Theme-Sakura/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 原demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 958139733 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢本站的sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 在次声明本博客主题其实以该(https://github.com/honjun/hexo-theme-sakura)源码的作者为基础，在此感谢其源码的提供，进行二次开发，改进…后面将为大家提供其为广大萌新使用者提供的教程. 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.bibilink.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"},{"name":"生活","slug":"生活","permalink":"/tags/生活/"},{"name":"资源","slug":"资源","permalink":"/tags/资源/"},{"name":"随想","slug":"随想","permalink":"/tags/随想/"},{"name":"图集","slug":"图集","permalink":"/tags/图集/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"idea","slug":"idea","date":"2020-12-12T14:16:01.000Z","updated":"2022-03-14T03:48:02.425Z","comments":false,"path":"2020/12/12/idea/","link":"","permalink":"/2020/12/12/idea/","excerpt":"","text":"后知后觉时间:2016-08-08 14:05:41 阅读:244 短文学:~芸萱残影~ 最美的遇见；最初的爱恋；最深的思念；最久的陪伴；最终化作一缕缕青烟～ 一起时，说着最伤人的话，做着最伤人的事，因为知道不会离开；离开时，依旧说着最伤人的话，做着最伤人的事，只不过主体变成了自己，那时才明白了什么叫刻骨铭心，什么叫痛定思痛…… 最怕突然的不见，最怕突然的思念，最怕无法再相恋……你的离开，带走的除了那颗爱你的心，还有我的灵魂；因为你，我的生活变得索然无味，我的人生变得空洞寂寞，每天的日子如同行尸走肉般不再富有朝气……仿佛一切都变成了思念，变成了情愫，渴望再次的遇见，再次的相恋。开始怀念昔日的美好，昔日的星空，昔日的绿林小路……于是怀揣着思念，去走来时的路，最后收获的仅仅四个字：物是人非。真是欲语泪先流…… 后来，明白了：逝去的终究逝去，未来还是要继续。于是，重振旗鼓，继续向前，只是多了一丝惆怅，一丝怅惘。内心告诉自己：谁的青春不疯狂，谁的青春不迷茫，谁的青春不犯错！青涩的爱情是我青春的过错，青春的遇见是哒哒的马蹄后的过客，我的归人就在灯火阑珊处等待我的蓦然回首！即使过错，不再错过，静待下一次遇见，善待下一次的感情。痛过才能更好的成蝶，恋过才能更好的蜕变！每一次的痛都会让我们更好的成长和成熟，那时的我们会真正的学会：即使泪水在眼里打转，却依旧可以微笑！ 遇见；相恋；理解；信任；包容地守护彼此！ 就像生活中从某些事看到你的影子，不觉然地笑了。才知道那永远回不去的从前，是多么的令人感到惬意。这是每个都有的恋旧情怀，不然又怎会好奇地来看看呢?","categories":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"},{"name":"生活","slug":"生活","permalink":"/tags/生活/"},{"name":"资源","slug":"资源","permalink":"/tags/资源/"},{"name":"随想","slug":"随想","permalink":"/tags/随想/"},{"name":"图集","slug":"图集","permalink":"/tags/图集/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}]},{"title":"转载","slug":"zhuanzai","date":"2020-12-12T14:16:01.000Z","updated":"2022-03-30T04:58:55.781Z","comments":false,"path":"2020/12/12/zhuanzai/","link":"","permalink":"/2020/12/12/zhuanzai/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 958139733","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"资源","slug":"资源","permalink":"/tags/资源/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]},{"title":"资源","slug":"ziyuan","date":"2020-12-12T14:16:01.000Z","updated":"2022-03-30T04:59:56.484Z","comments":false,"path":"2020/12/12/ziyuan/","link":"","permalink":"/2020/12/12/ziyuan/","excerpt":"","text":"关于一些技术类 网站工具箱，会后续分享………有关博主java相关的其它技术博客分享，请到主页点击CSDN等相关分享平台……. 支持url直接转md&amp;html转md以及在线预览的网页工具","categories":[{"name":"资源","slug":"资源","permalink":"/categories/资源/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"资源","slug":"资源","permalink":"/tags/资源/"}],"keywords":[{"name":"资源","slug":"资源","permalink":"/categories/资源/"}]},{"title":"mybatis和mybatisplus区别","slug":"mybatis和mybatisplus区别","date":"2020-10-02T00:32:51.000Z","updated":"2022-04-02T12:23:21.841Z","comments":false,"path":"2020/10/02/mybatis和mybatisplus区别/","link":"","permalink":"/2020/10/02/mybatis和mybatisplus区别/","excerpt":"","text":"实际开发的话，如果纯粹用mybatis，开局就要先把单表增删改查给做了，其实工作量还好， 但是表一多就很繁琐，如果表结构发生改变，加了字段之类的，就要维护这个单表crud的所有语句，每个语句维护要增减的字段mybatis默认解决单表的crud，是靠 mybatis generator，简称MBG，用来生成单表的mapper，xml等，但是有一个缺点，表结构发生改变的时候，重新生成会覆盖掉原来的，所以就无法直接在生成的xml上改。 Mybatis Plus：国人团队苞米豆在Mybatis的基础上开发的框架，在Mybatis基础上扩展了许多功能，荣获了2018最受欢迎国产开源软件第5名。Mybatis Plus Generator：同样为苞米豆开发，比Mybatis Generator更加强大，支持功能更多，自动生成Entity、Mapper、Service、Controller等。 特点： 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 MyBatis-plus 是一款 Mybatis 增强工具，用于简化开发，提高效率。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Vue结合项目开发 踩坑....","slug":"Vue结合项目开发 踩坑....","date":"2020-09-06T04:41:24.000Z","updated":"2022-03-30T04:57:44.256Z","comments":false,"path":"2020/09/06/Vue结合项目开发 踩坑..../","link":"","permalink":"/2020/09/06/Vue结合项目开发 踩坑..../","excerpt":"","text":"直接上图：原因很简单，但是就是没想到，哎启动目录问题：应该到对应的Vue项目路径下去运行npm run serve 我们可以在终端输入： cd [你的项目名]也可以，用idea可视化操作： 以为这就行了？很快啊，其实又来了一个常见的坑。这个98%真的很恐怖。显示了This relative module was not found:真的不要多想，马上去找你的路径问题….最终定位到这一行代码上改成“.”就好了。这样就成功了！ 背景图片不加载1.先去看引用路径对不对2.去找自己页面配置","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"IDEA","slug":"IDEA","permalink":"/tags/IDEA/"},{"name":"Vue","slug":"Vue","permalink":"/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"/tags/前端/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"hexo的简要使用文档","slug":"hello-world","date":"2020-07-26T02:16:01.000Z","updated":"2022-03-30T04:41:47.542Z","comments":true,"path":"2020/07/26/hello-world/","link":"","permalink":"/2020/07/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]},{"title":"【转载及推荐】Vue，webpack，node之间的关系","slug":"Vue学习疑问：你一口一个渲染、挂载所以到底应该怎么理解？","date":"2020-06-20T16:01:30.000Z","updated":"2022-03-30T04:56:40.936Z","comments":false,"path":"2020/06/21/Vue学习疑问：你一口一个渲染、挂载所以到底应该怎么理解？/","link":"","permalink":"/2020/06/21/Vue学习疑问：你一口一个渲染、挂载所以到底应该怎么理解？/","excerpt":"","text":"前情提要：在刚接触到vue时，总会出现几个名词：渲染、挂载、热更新等等，所以到底应该怎么去理解呢？以及引申到一些设计模式的知识，可以顺便了解。 Vue渲染方式 Vue中的渲染方式个人总结可分为4种: 原有模板语法，挂载渲染 使用render属性，createElement函数直接渲染 使用render属性，配合组件的template属性，createElement函数渲染 使用render属性，配合单文件组件，createElement函数渲染 超详细的Vue渲染原理讲解MVVM、MVP和MVCMVVM，即model、view、view-model，业务层、视图层以及两者的绑定层。Vue的设计参考了MVVM架构，但不完全是一个MVVM框架，因为它没有严格意义上的绑定层。 MVVM要求开发者将业务层和视图层分开：业务层负责管理数据；视图层负责页面渲染；绑定层负责双向绑定，即视图层操作通过绑定层影响业务数据，业务数据的变化通过绑定层影响视图渲染，这三层是完全解耦的：MVVM模式参考自MVP模式，而两者都是借鉴自经典的MVC模式。先来说说MVVM和MVP的差异。开发者需要定义当变量变化时如何更新视图，以及获取到用户输入时如何更新变量，这两者加起来就是它的Presenter层实现。这种方式也可以实现视图和业务逻辑的同步，但显然，MVP的控制层逻辑要比MVVM的声明式绑定写起来复杂得多，所以MVP模式基本上已经被MVVM代替。 vue和react渲染的区别是什么？区别：1、React是通过JSX渲染模板；而Vue是通过一种拓展的HTML语法进行渲染。2、Vue在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树；而React在应用的状态被改变时，全部子组件都会重新渲染。知乎文章：https://zhuanlan.zhihu.com/p/100228073 react和vue该选哪一个? 挂载挂载一词来自操作系统的概念，原意是虚拟文件系统与硬件驱动建立关系，通过操作虚拟文件系统，间接操作真实的文件。打个比方，u盘操作的实质是通过虚拟文件系统建立与真实u盘文件的映射关系，用户操作的文件增删改查都是针对虚拟文件目录，虚拟文件系统会处理真实的文件操作。u盘真实文件系统与虚拟文件系统建立关系的过程，叫做挂载。回到浏览器上，虚拟dom与真实dom建立关系的过程，也可以称作挂载。因为都是“虚拟”与“真实”建立联系，用户操作“虚拟”部分。 vue组件挂载与html加载区别,vue中的挂载是什么意思? 将组件渲染，并且构造 DOM 元素然后塞入页面的过程称为组件的挂载。 热更新有个脱俗且有趣的解释 就是说 你的卡车开到了150KM/H 然后，有个轮胎，爆了 然后，司机说，你就直接换吧，我不停车。你小心点换 嗯。就这个意思 vue是响应式的,设计模式是observer pattern(观察者模式) 面向对象23种设计模式日常开发中常用到哪些设计模式Java笔记：SpringBoot热部署与热加载深入解析spring中用到的九种设计模式极力推荐这一篇文章设计模式的文章，举例清晰。","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"Vue","slug":"Vue","permalink":"/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"/tags/前端/"},{"name":"设计模式","slug":"设计模式","permalink":"/tags/设计模式/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]},{"title":"【转载及推荐】Vue，webpack，node之间的关系","slug":"【转载及推荐】Vue，webpack，node之间的关系","date":"2020-06-11T08:31:24.000Z","updated":"2022-03-30T05:04:46.552Z","comments":false,"path":"2020/06/11/【转载及推荐】Vue，webpack，node之间的关系/","link":"","permalink":"/2020/06/11/【转载及推荐】Vue，webpack，node之间的关系/","excerpt":"","text":"【知识】Vue，webpack，node之间的关系 vue的开发本身是不依赖node的，不过vue的脚手架工具vue-cli里面集成的webpack*是基于node开发出来的。*因此只能说webpack是依赖node的。 npm run dev本质也是起一个服务，不过是利用node起的服务，起的是前端项目的服务；两者没有联系。(你可以使用npm run命令来运行package.json文件中scripts里的任何条目) 现在的前端项目大多通过webpack管理，webpack又是基于node，node是一个运行在服务器端的js环境，浏览器本身不支持的scss、es6/es7语法、typescript等都可在node这通过工具包npm去解决.因此前端项目起的node服务一般是为了解决这些问题。 作者：Xttaoamz链接：https://www.jianshu.com/p/e4e519bec5dc来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 简书文章：webpack4入门到放弃作者：温酒居士链接：https://www.jianshu.com/p/0f4333009edd推荐原因：教程详细，步骤明了。","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"Vue","slug":"Vue","permalink":"/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"/tags/前端/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]},{"title":"Vue _ vue cli新手入门 详细解读","slug":"Vue _ vue cli新手入门 详细解读","date":"2020-05-06T04:41:24.000Z","updated":"2022-03-30T04:55:52.936Z","comments":false,"path":"2020/05/06/Vue _ vue cli新手入门 详细解读/","link":"","permalink":"/2020/05/06/Vue _ vue cli新手入门 详细解读/","excerpt":"","text":"前言本文将从vue cli项目中的入口文件入手，深入浅出地解析vue cli在开发环境下的工程的运行原理。 一、有关vue cli 3(选读）1.1 本文解析采用cli 2做示例，但原理同样适用于vue cli 3若你是cli 3开发者，参考本文时，仅需注意cli 3的三点改动： cli 3内化了项目默认配置(相关文件位于node_modules/@vue/cli-service/lib/config），开发者可通过新增vue.config.js添加webpack配置。 index.html被放到了public文件夹下 webpack配置的书写使用webpack-chain 风格 1.2 查看vue版本号、vue-cli版本号1.2.1 查看vue版本号方法一：npm ls vue方法二：package.json 1.2.1 查看vue-cli版本号 1.3 vue-cli下载最新版本卸载2.x版本的vue-cli ：npm uninstall -g vue-cli 或 yarn global remove vue-cli 安装3.x版本的@vue/cli ：npm install -g @vue/cli或 yarn global add @vue/cli 再次输入 vue -V 检验： 二、入口文件的概述 在vue cli构建的项目中，main.js是项目的入口文件，定义了vue实例，并引入根组件app.vue，将其挂载到index.html中id为app的节点上。2.1 main.js:2.1.1 两种方式：在Vue构造函数时，需要配置一个el属性但是也可以像我一样这么写2.1.2 render函数的作用render函数是vue通过js渲染dom结构的函数createElement，约定可以简写为h render: h =&gt; h(App) 缩写前 render:function(createElement){ return createElement(App); } 进一步缩写为(ES6 语法) render(createElement){ return createElement(App); } 再进一步缩写为： render(h){ return h(App) } 按照 ES6 箭头函数的写法，就得到了： h =&gt; h(App) 实际渲染 import App from &#39;./App&#39; import Vue from &#39;vue&#39; new Vue({ el:&#39;#root&#39;, template:&#39;&lt;App&gt;&lt;/App&gt;&#39;, components:{ App } }) 手动挂载 在Vue构造函数时，需要配置一个el属性，如果没有没有el属性时，可以使用.$mount(&#39;#app&#39;)进行挂载。 // 配置了el属性： new Vue({ el:&quot;#app&quot;, router }); // 如果没有配置el属性，可以使用手动挂载$mount(&quot;#app&quot;) new Vue({ router }).$mount(&#39;#app&#39;); 官方解释翻译：它来自单词 hyperscript，这个单词通常用在 virtual-dom 的实现中。Hyperscript 本身是指 生成HTML 结构的 script 脚本，因为 HTML 是 hyper-text markup language 的缩写（超文本标记语言） createElement 函数是用来生成 HTML DOM 元素的，也就是上文中的 generate HTMLstructures，也就是 Hyperscript，这样作者才把 createElement 简写成 h。 h是 Vue.js 里面的createElement 函数，这个函数的作用就是生成一个 VNode节点，render 函数得到这个 VNode 节点之后，返回给 Vue.js 的 mount 函数，渲染成真实 DOM 节点，并挂载到根节点上 注意：vue实例挂载后，会对节点原内容进行覆盖。所以，即便index.html和app.vue中都定义了&lt;div id=&quot;app&quot;&gt;&lt;/app&gt;, 最终网页也不会出现两个id为app的节点。 2.2 index.html：&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;/body&gt; 2.3 app.vue:&lt;template&gt; &lt;div id=&quot;app&quot;&gt; ..... &lt;/div&gt; &lt;/template&gt; 三、问题main.js的作用已经明了，但仍有三个疑问: main.js为什么叫入口文件，什么是“入口文件”？ 在运行npm run dev后，若不做特殊设置，index.html实际页面中仅挂载了app.js一个脚本，所有组件去哪儿了，app.js是如何形成的？ vue实例化在main.js中，但在index.html中并没有引入main.js，main.js与index.html是如何产生关联的? 四、原因：Webpackvue cli搭建的项目本质是一个集成预设置的webpack项目。是webpack驱动着项目的打包，热重载和本地运行。而上述问题都是由webpack逐一处理的： 入口文件是一个webpack概念；入口文件是webpack构建内部依赖图的起点。 app.js是由webpack打包生成的输出文件。 而将app.js挂载到index.html这一过程是由webpack的一个插件——html-webpack-plugin完成的。 4.1 什么是webpackwebpack 是JavaScript 应用程序的静态模块打包器。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图，然后将应用程序所需的所有模块打包成一个或多个 bundle。 4.2 webpack的核心作用 浏览器仅能识别html,css和js，而无法识别封装的less,vue,jsx等文件，而webpack则可以将这些文件解析打包成浏览器能识别的基本文件。 模块化开发中，我们会编写大量模块，如果不打包就上线，那么页面加载或交互时，将会发起大量资源请求。为了性能优化，需要使用webpack这样的打包器对模块进行打包整合，以减少请求数。就像简单的vue项目，所有组件最终都将被打包到一个app.js中。 相较于无差别打包依赖模块的传统打包器，webpack的核心优势在于它从入口文件出发，递归构建依赖关系图。通过这样的依赖梳理，webpack打包出的bundle不会包含重复或未使用的模块，实现了按需打包，极大的减少了冗余。 4.3 webpack配置文件 vue cli 2 在build目录下默认有三种场景配置 ——webpack.base/dev/prod.conf.jsbase是基础配置，dev/prod分别是开发和产品场景的配置，它们在merge基础配置后追加或覆盖相关配置。 const devWebpackConfig = merge(baseWebpackConfig, { // 开发环境设置 }) 在运行或打包时，会根据你的命令选择不同的配置文件。脚本配置是写在package.json中的，如npm run dev就是使用开发环境配置。 &quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;, &quot;start&quot;: &quot;npm run dev&quot;, &quot;build&quot;: &quot;node build/build.js&quot; } 一份配置包含了入口文件，输出和各种插件的配置。 4.4 vue的入口文件设置 在webpack.base/webpack.dev中，vue默认设置main.js为项目的唯一入口。在项目打包时，webpack会从main.js开始构建依赖图，梳理整个项目依赖且不重复的模块。入口配置如下： entry: { app: &#39;./src/main.js&#39; }, 4.4.1 入口设置延伸（选读） webpack的入口设置，这里不展开讲。如果你要做多页面项目，而非默认的SPA，那么你要为每个页面设置一个入口。如果你要将app与第三方库分离，也要设置两个入口。这些操作可参考webpack的官方文档 webpack官方文档https://www.webpackjs.com/concepts/entry-points/ 如果你想要封装自己的UI库，那么在入口部分的设置，你可以参考以下这篇文章。 实现element-ui的按需引入，按需打包加载 https://segmentfault.com/a/1190000015884948 4.5 输出文件配置 配置中还定义了项目的输出设定。在output中，你可以配置打包输出文件的路径，名称，进行分离js/css等操作。 // webpack.base.conf output: { path: config.build.assetsRoot, filename: &#39;[name].js&#39;, publicPath: process.env.NODE_ENV === &#39;production&#39; ? config.build.assetsPublicPath : config.dev.assetsPublicPath }, 这里只讲一下 filename 这一属性：filename定义的是输出文件的名称，[name]是webpack中的占位符，它对应entry中对象的键名。默认配置中仅有一个入口–app。所以，在默认的开发模式下，本项目的所有资源最终打包生成的文件就是app.js。注：在开发模式下，项目是跑在webpack-dev-server的虚拟服务器上，此时app.js仅存在于内存中。 4.6 HtmlWebpackPlugin配置 vue的webpack默认配置中还加入了htmlwebpackplugin插件，用于生成index.html与挂载JS脚本。配置参数中：filename是输出文件名，template是本地模板文件名，HtmlWebpackPlugin默认挂载的模板就是根目录下的index.html。inject属性定义了js脚本加载的位置，默认值true，则在body最下方加载。你还可以添加其它参数，比如网站图标favicon等，这一系列参数均可参考webpack官方文档。 new HtmlWebpackPlugin({ filename: &#39;index.html&#39;, template: &#39;index.html&#39;, inject: true, favicon:&#39;static/img/temple.png&#39; }) 五、 总结当你输入 npm run dev 后，发生了这样一连串事件：webpack选择了开发配置，并进入main.js入口文件，构建项目依赖图。webpack将整理后的所有依赖模块打包成输出文件app.js，接着htmlwebpackPlugin将它挂载到index.html页面上。最终，它呈现出的模样如下所示：","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"IDEA","slug":"IDEA","permalink":"/tags/IDEA/"},{"name":"Vue","slug":"Vue","permalink":"/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"/tags/前端/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"从零搭建考试系统——多模块的项目环境搭建（idea）","slug":"从零搭建考试系统——多模块的项目环境搭建（idea）","date":"2020-04-10T22:41:24.000Z","updated":"2022-03-30T05:06:33.664Z","comments":false,"path":"2020/04/11/从零搭建考试系统——多模块的项目环境搭建（idea）/","link":"","permalink":"/2020/04/11/从零搭建考试系统——多模块的项目环境搭建（idea）/","excerpt":"","text":"1.项目父模块创建 2.项目子模块创建","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"解决方案","slug":"解决方案","permalink":"/tags/解决方案/"},{"name":"IDEA","slug":"IDEA","permalink":"/tags/IDEA/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"【数据结构】栈和队列","slug":"【数据结构】栈和队列","date":"2020-04-10T10:19:29.000Z","updated":"2022-04-11T14:20:08.494Z","comments":false,"path":"2020/04/10/【数据结构】栈和队列/","link":"","permalink":"/2020/04/10/【数据结构】栈和队列/","excerpt":"","text":"栈是先进后出，队列是先进先出。是2种重要的线性数据结构，和线性表相比，他们的插入和删除受到更多的约束与限定，因此称为限定的线性表结构。 栈的实现（数组或者链表、LinkedList）但是这两种方法都不是线程安全的，如果要实现线程安全，需要对入栈和出栈进行同步操作。 数组实现的话，主要是要实现pop和push函数，以及peek查找栈顶，然后push的时候如果容量不够的话，需要扩容。 链表实现的话，也是主要实现push和pop函数，以及peek查找栈顶，需要注意的是，push的时候，要把新的数据放在上一个数据前面，这样才能实现先进后出。 数组实现：import java.util.Arrays; /** * 数组实现栈 * @param &lt;T&gt; */ class Mystack1&lt;T&gt; { //实现栈的数组 private Object[] stack; //数组大小 private int size; Mystack1() { stack = new Object[10];//初始容量为10 } //判断是否为空 public boolean isEmpty() { return size == 0; } //返回栈顶元素 public T peek() { T t = null; if (size &gt; 0) t = (T) stack[size - 1]; return t; } public void push(T t) { expandCapacity(size + 1); stack[size] = t; size++; } //出栈 public T pop() { T t = peek(); if (size &gt; 0) { stack[size - 1] = null; size--; } return t; } //扩大容量 public void expandCapacity(int size) { int len = stack.length; if (size &gt; len) { size = size * 3 / 2 + 1;//每次扩大50% stack = Arrays.copyOf(stack, size); } } } public class ArrayStack { public static void main(String[] args) { Mystack1&lt;String&gt; stack = new Mystack1&lt;&gt;(); System.out.println(stack.peek()); System.out.println(stack.isEmpty()); stack.push(&quot;java&quot;); stack.push(&quot;is&quot;); stack.push(&quot;beautiful&quot;); stack.push(&quot;language&quot;); System.out.println(stack.pop()); System.out.println(stack.isEmpty()); System.out.println(stack.peek()); } } 链表实现：/** * 链表实现栈 * * @param &lt;T&gt; */ class Mystack2&lt;T&gt; { //定义链表 class Node&lt;T&gt; { private T t; private Node next; } private Node&lt;T&gt; head; //构造函数初始化头指针 Mystack2() { head = null; } //入栈 public void push(T t) { if (t == null) { throw new NullPointerException(&quot;参数不能为空&quot;); } if (head == null) { head = new Node&lt;T&gt;(); head.t = t; head.next = null; } else { Node&lt;T&gt; temp = head; head = new Node&lt;&gt;(); head.t = t; head.next = temp; } } //出栈 public T pop() { T t = head.t; head = head.next; return t; } //栈顶元素 public T peek() { T t = head.t; return t; } //栈空 public boolean isEmpty() { if (head == null) return true; else return false; } } public class LinkStack { public static void main(String[] args) { Mystack2 stack = new Mystack2(); System.out.println(stack.isEmpty()); stack.push(&quot;Java&quot;); stack.push(&quot;is&quot;); stack.push(&quot;beautiful&quot;); System.out.println(stack.peek()); System.out.println(stack.peek()); System.out.println(stack.pop()); System.out.println(stack.pop()); System.out.println(stack.isEmpty()); System.out.println(stack.pop()); System.out.println(stack.isEmpty()); } } LinkedList实现： push—–addFirst() pop——-removeFirst() peek—–getFirst() isEmpty-isEmpty() import java.util.LinkedList; /** * LinkedList实现栈 * * @param &lt;T&gt; */ class ListStack&lt;T&gt; { private LinkedList&lt;T&gt; ll = new LinkedList&lt;&gt;(); //入栈 public void push(T t) { ll.addFirst(t); } //出栈 public T pop() { return ll.removeFirst(); } //栈顶元素 public T peek() { T t = null; //直接取元素会报异常，需要先判断是否为空 if (!ll.isEmpty()) t = ll.getFirst(); return t; } //栈空 public boolean isEmpty() { return ll.isEmpty(); } } public class LinkedListStack { public static void main(String[] args) { ListStack&lt;String&gt; stack = new ListStack(); System.out.println(stack.isEmpty()); System.out.println(stack.peek()); stack.push(&quot;java&quot;); stack.push(&quot;is&quot;); stack.push(&quot;beautiful&quot;); System.out.println(stack.peek()); System.out.println(stack.pop()); System.out.println(stack.isEmpty()); System.out.println(stack.peek()); } } 队列的实现（数组和链表、LinkedList） 链表实现的话，和栈就不一样了，把新数据放在上一个的后面。需要实现在这里插入代码片put和pop函数 数组实现的话，使用LinkedList，就非常简单，只是需要注意pop函数里面，删除的是第一个元素，不是最后一个 链表实现：package com.wp.datastruct; /** * 利用链表来实现队列 * */ public class MyQueue&lt;E&gt; { Node head = null; //队列头 Node tail = null; //队列尾 /** * 入队操作： * 若该队列尾空，则入队节点既是头结点也是尾节点 * 若队列不为空，则先用tail节点的next指针指向该节点 * 然后将tail节点指向该节点 * */ public void put(Integer data) { Node newNode = new Node(data); //构造一个新节点 if(head == null &amp;&amp; tail == null) { //队列为空 head = newNode; tail = newNode; }else { tail.next = newNode; tail = newNode; } } /** * 判断队列是否为空：当头结点等于尾节点的时候该队列就为空 * */ public boolean isEmpty() { return head == tail; } /** * 出队操作： * 若队列为空，则返回null * 否则，返回队列的头结点，并将head节点指向下一个 * */ public Integer pop() { if(this.isEmpty()) { return null; } int data = head.data; head = head.next; return data; } public int size() { int count = 0; Node tmp = head; while(tmp != null) { count++; tmp = tmp.next; } return count; } } LinkedList实现： public class MyQueue2&lt;E&gt; { private LinkedList&lt;E&gt; list = new LinkedList&lt;&gt;(); private int size = 0; //用于统计队列的长度 public synchronized void put(E data) { //保证线程安全，实现同步操作 list.add(data); size++; } public synchronized E pop() { size--; return list.removeFirst(); //从头取出 } public synchronized int size() { return size; } public boolean isEmpty() { return size == 0; } } 实现代码参考 栈和队列的区别 栈【堆箱子】 队列【水管】 规则 先进后出，后进先出（LIFO） 先进先出，后进后出(FIFO) 插入和删除操作的限定 只能在表的一端插入和删除。 只能在表的一端进行插入，并在表的另一端进行删除 遍历数据速度 只能从顶部取数据，也就是说最先进入栈底的，需要遍历整个栈才能取出来，而且在遍历数据的同时需要为数据开辟临时空间，保持数据在遍历前的一致性。 基于地址指针进行遍历，而且可以从头部或者尾部进行遍历，但不能同时遍历，无需开辟空间，因为在遍历的过程中不影响数据结构，所以遍历速度要快 接口实现的异同 栈由List接口实现 队列由Queue接口实现 应用 “表达式求值”，“过滤器及拦截器的执行顺序” 处理”环状缓存区”,”排队算法”，游标属于单向队列","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"大学生活","slug":"daxueshenghuo","date":"2019-12-12T14:16:01.000Z","updated":"2022-03-30T07:39:20.779Z","comments":false,"path":"2019/12/12/daxueshenghuo/","link":"","permalink":"/2019/12/12/daxueshenghuo/","excerpt":"","text":"大学时的军训第一天 下起了小雨，只好收编返回宿舍，得劲儿 在当时手里没有优盘，临时拼凑起来一个 记一次冬至来临，作为寝室长特意提议大伙儿小聚小餐一顿 还有许多有趣的记录，有空再传嘞…https://cdn.jsdelivr.net/gh/w7h1te/PicGoCDN/img/bolg/psb.jfif","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"生活","slug":"生活","permalink":"/tags/生活/"},{"name":"图集","slug":"图集","permalink":"/tags/图集/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"哔哩哔哩外链插入","slug":"bibilink","date":"2019-12-12T14:16:01.000Z","updated":"2022-03-30T04:30:16.264Z","comments":true,"path":"2019/12/12/bibilink/","link":"","permalink":"/2019/12/12/bibilink/","excerpt":"","text":"hexo-tag-bili在Hexo博客文章或者单页面中加入样式优美bilibili外链播放器。 语法:{% bili video_id %} 或 {% bili video_id page %} 使用方式在Hexo博客目录使用npm安装插件 npm i hexo-tag-bili –save在Hexo博客的文章或者单页面中使用以下标签语法插入视频 {% bili video_id %} 或 {% bili video_id page %} 例子:如果视频网址如：https://www.bilibili.com/video/av24897960 在文章中插入的标签语法为：{% bili 24897960 %} 如果视频网址如（第二页）：https://www.bilibili.com/video/av24897960/?p=2 在文章中插入的标签语法为：{% bili 24897960 2 %}","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"life","slug":"life","date":"2019-12-12T14:16:01.000Z","updated":"2022-03-30T07:39:20.770Z","comments":false,"path":"2019/12/12/life/","link":"","permalink":"/2019/12/12/life/","excerpt":"","text":"我当时的初中学校大门（旧貌） 还走了一段时间的后门，不过后来前面已经改建、翻新 这是在我家里收拾旧东西看到的，当时被一直延用下来ps:我可是语文第二任语文课代表啊! https://cdn.jsdelivr.net/gh/w7h1te/PicGoCDN/img/bolg/0.gif 对于母校回忆，还有更难忘的，那就是我所参与的抖空竹、篆刻、象棋竞赛等等。常常因为篆刻作品，弄到深夜 还有许多有趣的回忆，暂不赘述。你的母校现在怎么样了？","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"生活","slug":"生活","permalink":"/tags/生活/"},{"name":"图集","slug":"图集","permalink":"/tags/图集/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]}]}